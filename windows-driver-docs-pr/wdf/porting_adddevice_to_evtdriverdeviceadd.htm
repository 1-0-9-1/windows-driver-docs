<html xmlns:msxsl="urn:schemas-microsoft-com:xslt" xmlns:mssdk="winsdk" xmlns:script="urn:script" xmlns:build="urn:build" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="Description" content="Porting AddDevice to EvtDriverDeviceAdd"/>
<meta name="MSHAttr" content="PreferredSiteName:MSDN"/>
<meta name="MSHAttr" content="PreferredLib:/library/windows/hardware"/>
<title>Porting AddDevice to EvtDriverDeviceAdd</title>

<meta name="MS-HAID" content="kmdf.porting_adddevice_to_evtdriverdeviceadd"/>
<meta name="MS-HAID" content="wdf.porting_adddevice_to_evtdriverdeviceadd"/>


<link rel="STYLESHEET" type="text/css" HREF="../common/backsdk4.css"/>


</head>
<body>

<div id="mainSection">
<div class="clsServerSDKContent">
<h1><a id="wdf.porting_adddevice_to_evtdriverdeviceadd"></a>Porting AddDevice to EvtDriverDeviceAdd</h1>
</div>
<p>Every Kernel-Mode Driver Framework (KMDF) or User-Mode Driver Framework (UMDF) driver that supports Plug and Play must have an <a href="wdf.evtdriverdeviceadd"><i>EvtDriverDeviceAdd</i></a> callback, which is the functional equivalent of a WDM driver’s <a href="kernel.adddevice"><i>AddDevice</i></a> function.</p>
<p>A WDM <a href="kernel.adddevice"><i>AddDevice</i></a> function creates the device object, creates the device interfaces, and initializes WMI but also initializes numerous variables in the driver’s device extension. WDM drivers typically defer the creation of I/O queues and the interrupt object until the <a href="kernel.dispatchpnp"><i>DispatchPnP</i></a> function is called to handle an <a href="kernel.irp_mn_start_device"><b>IRP_MN_START_DEVICE</b></a> request.</p>
<p>The framework-based driver’s <a href="wdf.evtdriverdeviceadd"><i>EvtDriverDeviceAdd</i></a> callback creates a WDFDEVICE object to represent the device that has just been enumerated. It also performs numerous additional initialization tasks to provide the framework with the information that it requires to set up its own internal structures and the underlying WDM structures.</p>
<p>As a result, for most framework-based drivers the <a href="wdf.evtdriverdeviceadd"><i>EvtDriverDeviceAdd</i></a> callback is significantly longer than the corresponding WDM <a href="kernel.adddevice"><i>AddDevice</i></a> function. In a framework-based driver, nearly all of the device’s initialization code is in the <i>EvtDriverDeviceAdd</i> function.  However, in the WDM version, the initialization code tends to be spread out through multiple functions in the driver.</p>
<p>The code in <a href="wdf.evtdriverdeviceadd"><i>EvtDriverDeviceAdd</i></a>  appears in the following order:<ol>
<li>Fill in the <a href="wdf.wdfdevice_init">WDFDEVICE_INIT</a> structure, which supplies information that is used to create the device object. For more information about using WDFDEVICE_INIT, see <a href="creating_a_framework_device_object.htm">Creating a Framework Device Object</a>.</li>
<li>Set up the device object’s context area, which is analogous to the WDM device extension.</li>
<li><a href="creating_a_framework_device_object.htm">Create the device object</a>.</li>
<li>Perform additional initialization and start-up tasks, such as <a href="creating_i_o_queues.htm">creating I/O queues</a> and <a href="creating_an_interrupt_object.htm">interrupt objects</a>.</li>
</ol>
</p>
<p>A KMDF bus driver typically creates multiple device objects: an FDO for its role as the function driver for the bus itself and a PDO for each child device that is attached to the bus. The framework calls the driver’s <a href="wdf.evtdriverdeviceadd"><i>EvtDriverDeviceAdd</i></a> function when the system enumerates the bus. The driver itself then enumerates its child devices and creates PDOs to represent them. KMDF supports both <a href="static_enumeration.htm">static</a>  and <a href="dynamic_enumeration.htm">dynamic</a> enumeration of child devices. It also includes additional PDO-specific features. </p>
<h2><a id="Device_Object_Context_Area"></a><a id="device_object_context_area"></a><a id="DEVICE_OBJECT_CONTEXT_AREA"></a>Device Object Context Area</h2>
<p>Drivers typically require storage that is associated with a device object to maintain pointers and object-specific data. In a WDM driver, the <b>DeviceExtension</b> field of the <a href="kernel.device_object"><b>DEVICE_OBJECT</b></a> structure provides such storage. In a framework-based driver, the object context area of the WDFDEVICE object serves the same purpose.</p>
<p>For  information about allocating and accessing context space for framework objects, see <a href="framework_object_context_space.htm">Framework Object Context Space</a>.</p>
<h2><a id="Device_Object_Creation"></a><a id="device_object_creation"></a><a id="DEVICE_OBJECT_CREATION"></a>Device Object Creation</h2>
<p>A WDM driver creates a <a href="kernel.device_object"><b>DEVICE_OBJECT</b></a> structure to represent each device object and attaches the device object to the Plug and Play device stack. Framework-based drivers also create device objects, which are referred to by using WDFDEVICE handles.</p>
<p>After the WDF driver calls the required initialization methods, it sets attributes for the device object (typically, the size and type of the context area) and then calls <a href="wdf.wdfdevicecreate"><b>WdfDeviceCreate</b></a> to create the device object. <b>WdfDeviceCreate</b> creates a WDFDEVICE object and an underlying WDM <a href="kernel.device_object"><b>DEVICE_OBJECT</b></a>, attaches the WDM <b>DEVICE_OBJECT</b> to the device stack, and returns a handle to the WDFDEVICE object.</p>
<h2><a id="Additional_EvtDriverDeviceAdd_Tasks"></a><a id="additional_evtdriverdeviceadd_tasks"></a><a id="ADDITIONAL_EVTDRIVERDEVICEADD_TASKS"></a>Additional EvtDriverDeviceAdd Tasks</h2>
<p>After the framework-based driver creates the device object, it should:</p>
<ul>
<li><a href="creating_i_o_queues.htm">Create I/O queues</a> and specify <a href="request_handlers.htm">request handlers</a> for the device object.</li>
<li><a href="using_device_interfaces.htm">Create device interfaces</a>.</li>
<li>Set <a href="supporting_idle_power_down.htm">device idle policy</a> and <a href="supporting_system_wake_up.htm">wake settings</a>, if the device object owns power policy.</li>
<li><a href="creating_an_interrupt_object.htm">Create an interrupt object</a>, if the hardware supports interrupts.</li>
<li><a href="supporting_wmi_in_kmdf_drivers.htm">Initialize WMI</a>.<sup>&#x2020;</sup></li>
</ul>
<p>&#x2020;&#160;This functionality is only available to KMDF drivers.</p>
<p>A framework-based driver should set up the I/O queues and create the interrupt object in the <a href="wdf.evtdriverdeviceadd"><i>EvtDriverDeviceAdd</i></a> callback, immediately after creating the device object. The framework connects the interrupt object and starts the queues at the appropriate time later, during start-device processing.</p>
<h2><a id="Child_Device_Enumeration__PDOs__KMDF_Only_"></a><a id="child_device_enumeration__pdos__kmdf_only_"></a><a id="CHILD_DEVICE_ENUMERATION__PDOS__KMDF_ONLY_"></a>Child Device Enumeration (PDOs, KMDF Only)</h2>
<p>A driver that controls a bus typically creates multiple device objects: an FDO for its role as the function driver for the bus itself and a PDO for each child device that is attached to the bus. KMDF supports both static and dynamic enumeration of child devices. It also includes additional PDO-specific features.</p>
<p>The framework invokes the driver’s <a href="wdf.evtdriverdeviceadd"><i>EvtDriverDeviceAdd</i></a> function when the Plug and Play manager enumerates the bus. <i>EvtDriverDeviceAdd</i> creates an FDO for the bus, and then enumerates the child devices and creates a PDO for each one. The driver can enumerate the child devices either <a href="static_enumeration.htm">statically</a> or <a href="dynamic_enumeration.htm">dynamically</a>.</p>
<p>Certain callback functions apply only to device objects that represent PDOs. When the driver initializes the device object, it registers the corresponding callbacks. PDOs respond to queries about device resources and resource requirements, requests to lock or eject the device, and requests to enable and disable the device wake signal.</p>
<p>In WDM drivers, these requests arrive as minor IRP codes in an <a href="kernel.irp_mj_pnp"><b>IRP_MJ_PNP</b></a> or <a href="kernel.irp_mj_power"><b>IRP_MJ_POWER</b></a> request. KMDF drivers handle them by implementing callbacks and registering the callbacks during device object initialization by calling <a href="wdf.wdfpdoinitseteventcallbacks"><b>WdfPdoInitSetEventCallbacks</b></a>. The following table lists the PDO-specific callbacks:</p>
<table>
<tr>
<th>KMDF callback </th>
<th>WDM IRP</th>
</tr>
<tr>
<td>
<p><a href="wdf.evtdeviceresourcesquery"><i>EvtDeviceResourcesQuery</i></a></p>
</td>
<td>
<p><a href="kernel.irp_mn_query_resources"><b>IRP_MN_QUERY_RESOURCES</b></a></p>
</td>
</tr>
<tr>
<td>
<p><a href="wdf.evtdeviceresourcerequirementsquery"><i>EvtDeviceResourceRequirementsQuery</i></a></p>
</td>
<td>
<p><a href="kernel.irp_mn_query_resource_requirements"><b>IRP_MN_QUERY_RESOURCE_REQUIREMENTS</b></a></p>
</td>
</tr>
<tr>
<td>
<p><a href="wdf.evtdeviceeject"><i>EvtDeviceEject</i></a></p>
</td>
<td>
<p><a href="kernel.irp_mn_eject"><b>IRP_MN_EJECT</b></a></p>
</td>
</tr>
<tr>
<td>
<p><a href="wdf.evtdevicesetlock"><i>EvtDeviceSetLock</i></a></p>
</td>
<td>
<p><a href="kernel.irp_mn_set_lock"><b>IRP_MN_SET_LOCK</b></a></p>
</td>
</tr>
<tr>
<td>
<p><a href="wdf.evtdeviceenablewakeatbus"><i>EvtDeviceEnableWakeAtBus</i></a></p>
</td>
<td>
<p><a href="kernel.irp_mn_wait_wake"><b>IRP_MN_WAIT_WAKE</b></a></p>
</td>
</tr>
<tr>
<td>
<p><a href="wdf.evtdevicedisablewakeatbus"><i>EvtDeviceDisableWakeAtBus</i></a></p>
</td>
<td>
<p><a href="kernel.irp_mn_wait_wake"><b>IRP_MN_WAIT_WAKE</b></a></p>
</td>
</tr>
</table>
<p> </p>
<p>Additional <b>WdfPdoInitXxx</b> methods enable the driver to specify device-specific data, such as device IDs.</p>
<p> </p>
<p> </p>
<p><a href="mailto:wsddocfb@microsoft.com?subject=Documentation%20feedback [wdf\wdf]:%20Porting AddDevice to EvtDriverDeviceAdd%20 RELEASE:%20(3/15/2016)&amp;body=%0A%0APRIVACY STATEMENT%0A%0AWe use your feedback to improve the documentation. We don't use your email address for any other purpose, and we'll remove your email address from our system after the issue that you're reporting is fixed. While we're working to fix this issue, we might send you an email message to ask for more info. Later, we might also send you an email message to let you know that we've addressed your feedback.%0A%0AFor more info about Microsoft's privacy policy, see http://privacy.microsoft.com/en-us/default.aspx." title="Send comments about this topic to Microsoft">Send comments about this topic to Microsoft</a></p>
</div>
<p style="text-align:left;font-family:Arial,sanserif;font-size:100%;color:black">
&#x00a9;&#x00a0;2016 Microsoft. All rights reserved.</p>

</body>
</html>
