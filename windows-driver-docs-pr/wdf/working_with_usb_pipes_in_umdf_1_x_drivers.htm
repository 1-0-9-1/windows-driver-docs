<html xmlns:msxsl="urn:schemas-microsoft-com:xslt" xmlns:mssdk="winsdk" xmlns:script="urn:script" xmlns:build="urn:build" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="Description" content="Working with USB Pipes in UMDF 1.x Drivers"/>
<meta name="MSHAttr" content="PreferredSiteName:MSDN"/>
<meta name="MSHAttr" content="PreferredLib:/library/windows/hardware"/>
<title>Working with USB Pipes in UMDF 1.x Drivers</title>

<meta name="MS-HAID" content="umdfobjectdg_99dddafa-f31b-403d-9292-1caaa1af2c16.xml"/>
<meta name="MS-HAID" content="umdf.working_with_usb_pipes_in_umdf"/>
<meta name="MS-HAID" content="wdf.working_with_usb_pipes_in_umdf"/>
<meta name="MS-HAID" content="wdf.working_with_usb_pipes_in_umdf_1_x_drivers"/>


<link rel="STYLESHEET" type="text/css" HREF="../common/backsdk4.css"/>


</head>
<body>

<div id="mainSection">
<div class="clsServerSDKContent">
<h1><a id="wdf.working_with_usb_pipes_in_umdf_1_x_drivers"></a>Working with USB Pipes in UMDF 1.x Drivers</h1>
</div>
<p class="CCE_Message">[This topic applies to UMDF 1.<i>x</i>.]</p>
<p>The framework represents each pipe in a USB interface as a framework USB pipe object. When a driver configures a USB device, the framework creates a framework USB pipe object for each pipe in each selected interface. Pipe object methods enable a driver to:</p>
<ul>
<li>
<p><a href="#obtaining_umdf_usb_pipe_information">Obtain pipe information</a>.</p>
</li>
<li>
<p><a href="#reading_from_a_umdf_usb_pipe">Read from a pipe</a>.</p>
</li>
<li>
<p><a href="#writing_to_a_umdf_usb_pipe">Write to a pipe</a>.</p>
</li>
<li>
<p><a href="#stopping_flushing">Stop, flush, or reset a pipe</a>.</p>
</li>
<li>
<p><a href="#setting_pipe_policy">Set pipe policy</a>.</p>
</li>
<li>
<p><a href="#handling_pipe_errors">Handle pipe errors</a>.</p>
</li>
</ul>
<h3><a id="obtaining_umdf_usb_pipe_information"></a><a id="OBTAINING_UMDF_USB_PIPE_INFORMATION"></a>Obtaining UMDF-USB Pipe Information</h3>
<p>After a UMDF driver calls the <a href="wdf.iwdfusbinterface_retrieveusbpipeobject"><b>IWDFUsbInterface::RetrieveUsbPipeObject</b></a> method to obtain a pointer to the <a href="wdf.iwdfusbtargetpipe">IWDFUsbTargetPipe</a> interface for a USB pipe object, the driver can call the following methods that the USB pipe object defines for obtaining information about the USB pipe: </p>
<p></p>
<dl>
<dt><a id="IWDFUsbTargetPipe__GetInformation"></a><a id="iwdfusbtargetpipe__getinformation"></a><a id="IWDFUSBTARGETPIPE__GETINFORMATION"></a><a href="wdf.iwdfusbtargetpipe_getinformation"><b>IWDFUsbTargetPipe::GetInformation</b></a></dt>
<dd>
<p>Retrieves information about a USB pipe and its endpoint. </p>
</dd>
<dt><a id="IWDFUsbTargetPipe__GetType"></a><a id="iwdfusbtargetpipe__gettype"></a><a id="IWDFUSBTARGETPIPE__GETTYPE"></a><a href="wdf.iwdfusbtargetpipe_gettype"><b>IWDFUsbTargetPipe::GetType</b></a></dt>
<dd>
<p>Returns the type of a USB pipe. </p>
</dd>
<dt><a id="IWDFUsbTargetPipe__IsInEndPoint"></a><a id="iwdfusbtargetpipe__isinendpoint"></a><a id="IWDFUSBTARGETPIPE__ISINENDPOINT"></a><a href="wdf.iwdfusbtargetpipe_isinendpoint"><b>IWDFUsbTargetPipe::IsInEndPoint</b></a></dt>
<dd>
<p>Determines whether a USB pipe is connected to an input endpoint. </p>
</dd>
<dt><a id="IWDFUsbTargetPipe__IsOutEndPoint"></a><a id="iwdfusbtargetpipe__isoutendpoint"></a><a id="IWDFUSBTARGETPIPE__ISOUTENDPOINT"></a><a href="wdf.iwdfusbtargetpipe_isoutendpoint"><b>IWDFUsbTargetPipe::IsOutEndPoint</b></a></dt>
<dd>
<p>Determines whether a USB pipe is connected to an output endpoint. </p>
</dd>
<dt><a id="IWDFUsbTargetPipe__RetrievePipePolicy"></a><a id="iwdfusbtargetpipe__retrievepipepolicy"></a><a id="IWDFUSBTARGETPIPE__RETRIEVEPIPEPOLICY"></a><a href="wdf.iwdfusbtargetpipe_retrievepipepolicy"><b>IWDFUsbTargetPipe::RetrievePipePolicy</b></a></dt>
<dd>
<p>Retrieves a WinUsb pipe policy. </p>
</dd>
</dl>
<h3><a id="reading_from_a_umdf_usb_pipe"></a><a id="READING_FROM_A_UMDF_USB_PIPE"></a>Reading from a UMDF-USB Pipe</h3>
<p>To read data from a USB input pipe, your driver can use either (or both) of the following techniques:</p>
<ul>
<li>
<p>Read data synchronously.</p>
<p>To read data synchronously from a USB input pipe, a UMDF driver first calls the <a href="wdf.iwdfiotarget_formatrequestforread"><b>IWDFIoTarget::FormatRequestForRead</b></a> method to build a read request. Then the driver calls the <a href="wdf.iwdfiorequest_send"><b>IWDFIoRequest::Send</b></a> method, specifying the WDF_REQUEST_SEND_OPTION_SYNCHRONOUS flag, to send the request synchronously.</p>
</li>
<li>
<p>Read data asynchronously.</p>
<p>To read data asynchronously from a USB input pipe, a UMDF driver first calls the <a href="wdf.iwdfiotarget_formatrequestforread"><b>IWDFIoTarget::FormatRequestForRead</b></a> method to build a read request. Then the driver calls the <a href="wdf.iwdfiorequest_send"><b>IWDFIoRequest::Send</b></a> method without specifying the WDF_REQUEST_SEND_OPTION_SYNCHRONOUS flag.</p>
</li>
<li>
<p>Read data synchronously and continuously.</p>
<p>A <i>continuous reader</i> is a framework-supplied mechanism that ensures a read request is always available to a USB pipe. This mechanism guarantees that the driver is always ready to receive data from a device that provides an asynchronous, unsolicited input stream. For example, a driver for a network interface card (NIC) might use a continuous reader to receive input data. </p>
<p>To configure a continuous reader for an input pipe, the driver's <a href="wdf.ipnpcallbackhardware_onpreparehardware"><b>IPnpCallbackHardware::OnPrepareHardware</b></a> callback function must call the <a href="wdf.iwdfusbtargetpipe2_configurecontinuousreader"><b>IWDFUsbTargetPipe2::ConfigureContinuousReader</b></a> method. This method queues a set of read requests to the device's I/O target. </p>
<p>Also, the driver's <a href="wdf.ipnpcallback_ond0entry"><b>IPnpCallback::OnD0Entry</b></a> callback function must call <a href="wdf.iwdfiotargetstatemanagement_start"><b>IWDFIoTargetStateManagement::Start</b></a> to start the continuous reader and the driver's <a href="wdf.ipnpcallback_ond0exit"><b>IPnpCallback::OnD0Exit</b></a> callback function must call <a href="wdf.iwdfiotargetstatemanagement_stop"><b>IWDFIoTargetStateManagement::Stop</b></a> to stop the continuous reader.</p>
<p>Each time that data is available from the device, the I/O target will complete a read request and the framework will call one of two callback functions: <a href="wdf.iusbtargetpipecontinuousreadercallbackreadcomplete_onreadercompletion"><b>IUsbTargetPipeContinuousReaderCallbackReadComplete::OnReaderCompletion</b></a> if the I/O target successfully read the data, or <a href="wdf.iusbtargetpipecontinuousreadercallbackreadersfailed_onreaderfailure"><b>IUsbTargetPipeContinuousReaderCallbackReadersFailed::OnReaderFailure</b></a> if the I/O target reports an error.</p>
<p>After a driver has called <a href="wdf.iwdfusbtargetpipe2_configurecontinuousreader"><b>IWDFUsbTargetPipe2::ConfigureContinuousReader</b></a>, the driver cannot use <a href="wdf.iwdfiorequest_send"><b>IWDFIoRequest::Send</b></a> to send I/O requests to the pipe unless the driver's <a href="wdf.iusbtargetpipecontinuousreadercallbackreadersfailed_onreaderfailure"><b>IUsbTargetPipeContinuousReaderCallbackReadersFailed::OnReaderFailure</b></a> callback function is called and returns <b>FALSE</b>.</p>
<p>Continuous readers are supported in UMDF versions 1.9 and later. </p>
</li>
</ul>
<h3><a id="writing_to_a_umdf_usb_pipe"></a><a id="WRITING_TO_A_UMDF_USB_PIPE"></a>Writing to a UMDF-USB Pipe</h3>
<p>To write data to a USB output pipe, a UMDF driver can first call the <a href="wdf.iwdfiotarget_formatrequestforwrite"><b>IWDFIoTarget::FormatRequestForWrite</b></a> method to build a write request. Then the driver can call the <a href="wdf.iwdfiorequest_send"><b>IWDFIoRequest::Send</b></a> method to send the request asynchronously.</p>
<h3><a id="stopping_flushing"></a><a id="STOPPING_FLUSHING"></a>Stopping, Flushing, and Resetting a UMDF-USB Pipe</h3>
<p>A UMDF driver can call the following methods to stop, flush, or reset a USB pipe:</p>
<p></p>
<dl>
<dt><a id="IWDFUsbTargetPipe__Abort"></a><a id="iwdfusbtargetpipe__abort"></a><a id="IWDFUSBTARGETPIPE__ABORT"></a><a href="wdf.iwdfusbtargetpipe_abort"><b>IWDFUsbTargetPipe::Abort</b></a></dt>
<dd>
<p>Synchronously sends a request to stop all pending transfers on a USB pipe. </p>
</dd>
<dt><a id="IWDFUsbTargetPipe__Flush"></a><a id="iwdfusbtargetpipe__flush"></a><a id="IWDFUSBTARGETPIPE__FLUSH"></a><a href="wdf.iwdfusbtargetpipe_flush"><b>IWDFUsbTargetPipe::Flush</b></a></dt>
<dd>
<p>Synchronously sends a request to discard any data that WinUsb saved when the device returned more data than the client requested. </p>
</dd>
<dt><a id="IWDFUsbTargetPipe__Reset"></a><a id="iwdfusbtargetpipe__reset"></a><a id="IWDFUSBTARGETPIPE__RESET"></a><a href="wdf.iwdfusbtargetpipe_reset"><b>IWDFUsbTargetPipe::Reset</b></a></dt>
<dd>
<p>Synchronously sends a request to reset a USB pipe. </p>
</dd>
</dl>
<h3><a id="setting_pipe_policy"></a><a id="SETTING_PIPE_POLICY"></a>Setting Policy for a UMDF-USB Pipe</h3>
<p>A UMDF driver can call the <a href="wdf.iwdfusbtargetpipe_setpipepolicy"><b>IWDFUsbTargetPipe::SetPipePolicy</b></a> method to control the behavior that is used by WinUsb for a USB pipe (for example, time-outs, handling short packets, and other behaviors). </p>
<h3><a id="handling_pipe_errors"></a><a id="HANDLING_PIPE_ERRORS"></a>Handling Pipe Errors</h3>
<p>If your driver's USB target <a href="completing_i_o_requests.htm">completes</a> an I/O request with an error status value, your driver should do the following:</p>
<ol>
<li>
<p>Call <a href="wdf.iwdfiotargetstatemanagement_stop"><b>IWDFIoTargetStateManagement::Stop</b></a> with the <b>WdfIoTargetCancelSentIo</b> flag set. This call stops the pipe and cancels any additional I/O requests that the driver has sent to the USB target, if the target has not completed the requests.</p>
</li>
<li>
<p>Call <a href="wdf.iwdfusbtargetpipe_abort"><b>IWDFUsbTargetPipe::Abort</b></a> to send an abort request to the pipe.</p>
</li>
<li>
<p>Call <a href="wdf.iwdfusbtargetpipe_reset"><b>IWDFUsbTargetPipe::Reset</b></a> to send a reset request to the pipe.</p>
</li>
<li>
<p>Call <a href="wdf.iwdfiotargetstatemanagement_start"><b>IWDFIoTargetStateManagement::Start</b></a> to restart the pipe.</p>
</li>
<li>
<p>Resend the I/O request that failed, and all I/O requests that followed the failed request. </p>
</li>
</ol>
<p> </p>
<p> </p>
<p><a href="mailto:wsddocfb@microsoft.com?subject=Documentation%20feedback [wdf\wdf]:%20Working with USB Pipes in UMDF 1.x Drivers%20 RELEASE:%20(3/15/2016)&amp;body=%0A%0APRIVACY STATEMENT%0A%0AWe use your feedback to improve the documentation. We don't use your email address for any other purpose, and we'll remove your email address from our system after the issue that you're reporting is fixed. While we're working to fix this issue, we might send you an email message to ask for more info. Later, we might also send you an email message to let you know that we've addressed your feedback.%0A%0AFor more info about Microsoft's privacy policy, see http://privacy.microsoft.com/en-us/default.aspx." title="Send comments about this topic to Microsoft">Send comments about this topic to Microsoft</a></p>
</div>
<p style="text-align:left;font-family:Arial,sanserif;font-size:100%;color:black">
&#x00a9;&#x00a0;2016 Microsoft. All rights reserved.</p>

</body>
</html>
