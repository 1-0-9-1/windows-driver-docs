<html xmlns:msxsl="urn:schemas-microsoft-com:xslt" xmlns:mssdk="winsdk" xmlns:script="urn:script" xmlns:build="urn:build" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="Description" content="WDM Concepts for WDF Drivers"/>
<meta name="MSHAttr" content="PreferredSiteName:MSDN"/>
<meta name="MSHAttr" content="PreferredLib:/library/windows/hardware"/>
<title>WDM Concepts for WDF Drivers</title>

<meta name="MS-HAID" content="Ch0_DFArchOverview_f8660a9f-ff02-4d68-b319-8343446de904.xml"/>
<meta name="MS-HAID" content="kmdf.wdm_concepts_for_framework_based_drivers"/>
<meta name="MS-HAID" content="kmdf.wdm_concepts_for_kmdf_drivers"/>
<meta name="MS-HAID" content="wdf.wdm_concepts_for_kmdf_drivers"/>


<link rel="STYLESHEET" type="text/css" HREF="../common/backsdk4.css"/>


</head>
<body>

<div id="mainSection">
<div class="clsServerSDKContent">
<h1><a id="wdf.wdm_concepts_for_kmdf_drivers"></a>WDM Concepts for WDF Drivers</h1>
</div>
<p>Windows Driver Frameworks (WDF) is a wrapper around Microsoft Windows Driver Model (WDM) interfaces. Although the framework simplifies many WDM concepts and hides others completely so that you do not have to work with them, you should still understand some of the basic concepts of WDM drivers. Specifically, you should understand <a href="#driver_types">driver types</a>, <a href="#driver_stacks">driver stacks</a>, <a href="#device_stacks">device stacks</a>, and <a href="#i_o_request_packets">I/O request packets</a>.</p>
<h3><a id="driver_types"></a><a id="DRIVER_TYPES"></a>Driver types</h3>
<p>Windows-based drivers are divided into three types: <a href="kernel.bus_drivers">bus drivers</a>, <a href="kernel.function_drivers">function drivers</a>, and <a href="kernel.filter_drivers">filter drivers</a>. Bus drivers support I/O buses by detecting child devices that are plugged into a parent bus and reporting their characteristics. (This activity is called <i>bus enumeration</i>.) Function drivers control I/O operations for devices and buses. Filter drivers receive, review, and possibly modify data that flows between user applications and drivers, or between individual drivers.</p>
<p>Drivers for buses are essentially function drivers that also enumerate children. A driver acts as a "bus driver" when it enumerates the child devices on a bus. Otherwise, the same driver acts as the "function driver" for the bus when it handles I/O operations that access the bus adapter's hardware.</p>
<p>A User-Mode Driver Framework (UMDF) driver cannot be a bus driver.</p>
<h3><a id="driver_stacks"></a><a id="DRIVER_STACKS"></a>Driver stacks</h3>
<p>In the Windows operating system, WDM drivers are layered in a vertical calling sequence that is called a <i>driver stack</i>. The topmost driver in the stack typically receives I/O requests from user applications, after the requests have passed through the operating system's I/O manager. The lower driver layers typically communicate with computer hardware. </p>
<p>A simple driver stack includes a bus driver at the bottom of the stack, which handles bus-specific I/O operations and enumerates the child devices that are connected to it. Typically, one or more device-specific function drivers are above the bus driver. These function drivers handle I/O operations to the devices that are connected to the bus. Filter drivers can be above the function drivers, or they can reside between a bus driver and function driver. A running system has several driver stacks that support different types of devices.</p>
<h3><a id="device_stacks"></a><a id="DEVICE_STACKS"></a>Device stacks</h3>
<p>Each driver stack supports one or more <i>device stacks</i>. A device stack is a set of <i>device objects</i> that are created from WDM-defined <a href="kernel.device_object"><b>DEVICE_OBJECT</b></a> structures. Each device stack represents one device. Each driver creates a device object for each of its devices and attaches each device object to a device stack. Device stacks are created and removed as devices are plugged in and unplugged, and each time the system is rebooted.</p>
<p>When a bus driver detects that child devices have been plugged in or unplugged, it informs the Plug and Play (PnP) manager. In response, the PnP manager asks the bus driver to create a physical device object (PDO) for each child device that is connected to the parent device (that is, the bus). The PDO becomes the bottom of a device stack.</p>
<p>Next, the PnP manager loads function and filter drivers to support each device (if they are not already loaded), and then the PnP manager calls these drivers so that each can create a device object and add it to the top of the device stack. Function drivers create functional device objects (FDOs), and filter drivers create filter device objects (filter DOs). </p>
<p>When the I/O manager sends an I/O request to a device's drivers, it passes the request to the driver that created the topmost device object in the device stack. If that driver asks the I/O manager to pass the request to the next-lower driver, the I/O manager uses the device stack to determine the next-lower driver. (The next-lower driver is the driver that created the next-lower device object.) </p>
<p>WDF creates a framework device object for each WDM device object. Framework-based drivers access these framework device objects instead of WDM device objects.</p>
<h3><a id="i_o_request_packets"></a><a id="I_O_REQUEST_PACKETS"></a>I/O request packets</h3>
<p>The I/O manager sends an application's I/O requests to drivers by creating I/O request packets (IRPs). An IRP can contain a request to perform an I/O operation (such as a read/write operation) or a request to perform an I/O control (IOCTL) action (such as returning status). In addition, the PnP manager creates IRPs that represent PnP and power management operations that drivers must perform, and it sends these IRPs to drivers.</p>
<p>Typically, the I/O manager creates a read or write IRP when a user application requests a read or write operation. The I/O manager passes the IRP to the driver at the top of the driver stack, and that driver either services the request or passes the request to the next-lower driver. Some requests travel to the bottom of the stack, and some are completely processed by higher-level drivers. </p>
<p>Each time a driver receives an IRP, the driver also receives a pointer to the device object that represents the device that must handle the operation. Therefore, the drivers in a driver stack use device objects to determine which of their plugged-in devices a particular request is supposed to go to.</p>
<p>WDF drivers typically do not directly access IRPs. The framework converts the WDM IRPs that represent read, write, and device I/O control operations to framework request objects that Kernel-Mode Driver Framework (KMDF) and UMDF drivers receive in I/O queues. The framework handles PnP and power management IRPs internally and uses event callback functions to inform the driver of PnP and power events.</p>
<p> </p>
<p> </p>
<p><a href="mailto:wsddocfb@microsoft.com?subject=Documentation%20feedback [wdf\wdf]:%20WDM Concepts for WDF Drivers%20 RELEASE:%20(3/15/2016)&amp;body=%0A%0APRIVACY STATEMENT%0A%0AWe use your feedback to improve the documentation. We don't use your email address for any other purpose, and we'll remove your email address from our system after the issue that you're reporting is fixed. While we're working to fix this issue, we might send you an email message to ask for more info. Later, we might also send you an email message to let you know that we've addressed your feedback.%0A%0AFor more info about Microsoft's privacy policy, see http://privacy.microsoft.com/en-us/default.aspx." title="Send comments about this topic to Microsoft">Send comments about this topic to Microsoft</a></p>
</div>
<p style="text-align:left;font-family:Arial,sanserif;font-size:100%;color:black">
&#x00a9;&#x00a0;2016 Microsoft. All rights reserved.</p>

</body>
</html>
