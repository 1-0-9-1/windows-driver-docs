<html xmlns:msxsl="urn:schemas-microsoft-com:xslt" xmlns:mssdk="winsdk" xmlns:script="urn:script" xmlns:build="urn:build" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="Description" content="Working with USB Pipes"/>
<meta name="MSHAttr" content="PreferredSiteName:MSDN"/>
<meta name="MSHAttr" content="PreferredLib:/library/windows/hardware"/>
<title>Working with USB Pipes</title>

<meta name="MS-HAID" content="Ch6_DFUSBPackage_26e1a8a4-b9cc-4279-a5b1-e2aa8145b63b.xml"/>
<meta name="MS-HAID" content="kmdf.working_with_usb_pipes"/>
<meta name="MS-HAID" content="wdf.working_with_usb_pipes"/>


<link rel="STYLESHEET" type="text/css" HREF="../common/backsdk4.css"/>


</head>
<body>

<div id="mainSection">
<div class="clsServerSDKContent">
<h1><a id="wdf.working_with_usb_pipes"></a>Working with USB Pipes</h1>
</div>
<p>The framework represents each pipe in a USB interface as a framework USB pipe object. When a driver <a href="working_with_usb_devices.htm#selecting_a_device_configuration">configures a USB device</a>, the framework creates a framework USB pipe object for each pipe in each selected interface. Pipe object methods enable a driver to perform the following operations:</p>
<ul>
<li>
<p><a href="#obtaining_pipe_information">Obtain pipe information.</a></p>
</li>
<li>
<p><a href="#reading_from_a_pipe">Read from a pipe.</a></p>
</li>
<li>
<p><a href="#writing_to_a_pipe">Write to a pipe.</a></p>
</li>
<li>
<p><a href="#stopping_and_resetting_a_pipe">Stop or reset a pipe.</a></p>
</li>
<li>
<p><a href="#sending_a_urb_to_a_pipe">Send a URB to a pipe.</a></p>
</li>
</ul>
<h3><a id="obtaining_pipe_information"></a><a id="OBTAINING_PIPE_INFORMATION"></a>
      Obtaining Pipe Information</h3>
<p>After calling <a href="wdf.wdfusbinterfacegetconfiguredpipe"><b>WdfUsbInterfaceGetConfiguredPipe</b></a> to obtain a handle to a framework USB pipe object, your driver can call the following methods that the USB pipe object defines for obtaining information about the USB pipe: </p>
<p></p>
<dl>
<dt><a id="_________WdfUsbTargetPipeGetIoTarget________"></a><a id="_________wdfusbtargetpipegetiotarget________"></a><a id="_________WDFUSBTARGETPIPEGETIOTARGET________"></a><a href="wdf.wdfusbtargetpipegetiotarget"><b>
        WdfUsbTargetPipeGetIoTarget
       </b></a></dt>
<dd>
<p>Returns a handle to the I/O target object that is associated with a USB pipe. The driver can pass this handle to <a href="wdf.wdfrequestsend"><b>WdfRequestSend</b></a>.</p>
</dd>
<dt><a id="_________WdfUsbTargetPipeGetInformation________"></a><a id="_________wdfusbtargetpipegetinformation________"></a><a id="_________WDFUSBTARGETPIPEGETINFORMATION________"></a><a href="wdf.wdfusbtargetpipegetinformation"><b>
        WdfUsbTargetPipeGetInformation
       </b></a></dt>
<dd>
<p>Retrieves information about a USB pipe and its endpoint.</p>
</dd>
<dt><a id="_________WdfUsbTargetPipeGetType________"></a><a id="_________wdfusbtargetpipegettype________"></a><a id="_________WDFUSBTARGETPIPEGETTYPE________"></a><a href="wdf.wdfusbtargetpipegettype"><b>
        WdfUsbTargetPipeGetType
       </b></a></dt>
<dd>
<p>Returns the type of a USB pipe.</p>
</dd>
<dt><a id="_________WdfUsbTargetPipeIsInEndpoint________"></a><a id="_________wdfusbtargetpipeisinendpoint________"></a><a id="_________WDFUSBTARGETPIPEISINENDPOINT________"></a><a href="wdf.wdfusbtargetpipeisinendpoint"><b>
        WdfUsbTargetPipeIsInEndpoint
       </b></a></dt>
<dd>
<p>Determines whether a USB pipe is connected to an input endpoint.</p>
</dd>
<dt><a id="_________WdfUsbTargetPipeIsOutEndpoint________"></a><a id="_________wdfusbtargetpipeisoutendpoint________"></a><a id="_________WDFUSBTARGETPIPEISOUTENDPOINT________"></a><a href="wdf.wdfusbtargetpipeisoutendpoint"><b>
        WdfUsbTargetPipeIsOutEndpoint
       </b></a></dt>
<dd>
<p>Determines whether a USB pipe is connected to an output endpoint.</p>
</dd>
<dt><a id="_________WDF_USB_PIPE_DIRECTION_IN________"></a><a id="_________wdf_usb_pipe_direction_in________"></a><a href="wdf.wdf_usb_pipe_direction_in"><b>
        WDF_USB_PIPE_DIRECTION_IN
       </b></a></dt>
<dd>
<p>Determines whether a USB endpoint is an input endpoint.</p>
</dd>
<dt><a id="_________WDF_USB_PIPE_DIRECTION_OUT________"></a><a id="_________wdf_usb_pipe_direction_out________"></a><a href="wdf.wdf_usb_pipe_direction_out"><b>
        WDF_USB_PIPE_DIRECTION_OUT
       </b></a></dt>
<dd>
<p>Determines whether a USB endpoint is an output endpoint.</p>
</dd>
</dl>
<p>For related information, see <a href="buses.how_to_get_usb_pipe_handles">How to enumerate USB pipes</a>.</p>
<h3><a id="reading_from_a_pipe"></a><a id="READING_FROM_A_PIPE"></a>
      Reading from a Pipe</h3>
<p>To read data from a USB input pipe, your driver can use any (or all) of the following three techniques:</p>
<ul>
<li>
<p>Read data synchronously</p>
<p>To read data synchronously from a USB input pipe, your driver can call the <a href="wdf.wdfusbtargetpipereadsynchronously"><b>WdfUsbTargetPipeReadSynchronously</b></a> method. This method builds and sends a read request, and it returns after the I/O operation has completed. </p>
</li>
<li>
<p>Read data asynchronously</p>
<p>To read data asynchronously from a USB input pipe, your driver can call the <a href="wdf.wdfusbtargetpipeformatrequestforread"><b>WdfUsbTargetPipeFormatRequestForRead</b></a> method to build a read request. Then the driver can call <a href="wdf.wdfrequestsend"><b>WdfRequestSend</b></a> to send the request asynchronously (or synchronously).</p>
</li>
<li>
<p>Read data asynchronously and continuously</p>
<p>A <i>continuous reader</i> is a framework-supplied mechanism for ensuring that a read request is always available to a USB pipe. This mechanism guarantees that the driver will always be ready to receive data from a device that provides an asynchronous, unsolicited input stream. For example, a driver for a network interface card (NIC) might use a continuous reader to receive input data. </p>
<p>To configure a continuous reader for an input pipe, the driver's <a href="wdf.evtdevicepreparehardware"><i>EvtDevicePrepareHardware</i></a> callback function must call the <a href="wdf.wdfusbtargetpipeconfigcontinuousreader"><b>WdfUsbTargetPipeConfigContinuousReader</b></a> method. This method queues a set of read requests to the device's I/O target. </p>
<p>Also, the driver's <a href="wdf.evtdeviced0entry"><i>EvtDeviceD0Entry</i></a> callback function must call <a href="wdf.wdfiotargetstart"><b>WdfIoTargetStart</b></a> to start the continuous reader and the driver's <a href="wdf.evtdeviced0exit"><i>EvtDeviceD0Exit</i></a> callback function must call <a href="wdf.wdfiotargetstop"><b>WdfIoTargetStop</b></a> to stop the continuous reader.</p>
<p>Each time that data is available from the device, the I/O target will complete a read request and the framework will call one of two callback functions: <a href="wdf.evtusbtargetpipereadcomplete"><i>EvtUsbTargetPipeReadComplete</i></a><u>,</u> if the I/O target successfully read the data, or <a href="wdf.evtusbtargetpipereadersfailed"><i>EvtUsbTargetPipeReadersFailed</i></a><u>,</u> if the I/O target reports an error.</p>
<p>If you do not supply the optional <a href="wdf.evtusbtargetpipereadersfailed"><i>EvtUsbTargetPipeReadersFailed</i></a> callback, the framework responds to a failed read attempt by sending another read request. Therefore if the bus is in a state where it is not accepting reads, the framework continually sends new requests to recover from a failed read.</p>
<p>After a driver has called <a href="wdf.wdfusbtargetpipeconfigcontinuousreader"><b>WdfUsbTargetPipeConfigContinuousReader</b></a>, the driver cannot use <a href="wdf.wdfusbtargetpipereadsynchronously"><b>WdfUsbTargetPipeReadSynchronously</b></a> or <a href="wdf.wdfrequestsend"><b>WdfRequestSend</b></a> to send I/O requests to the pipe unless the driver's <a href="wdf.evtusbtargetpipereadersfailed"><i>EvtUsbTargetPipeReadersFailed</i></a> callback function is called and returns <b>FALSE</b>.</p>
</li>
</ul>
<p>By default, the framework reports an error if your driver specifies a read buffer that is not a multiple of the pipe's maximum packet size. Your driver can call <a href="wdf.wdfusbtargetpipesetnomaximumpacketsizecheck"><b>WdfUsbTargetPipeSetNoMaximumPacketSizeCheck</b></a> to disable this test of read buffer sizes.</p>
<p>For related information, see:</p>
<ul>
<li><a href="buses.usb_bulk_and_interrupt_transfer">How to send USB bulk transfer requests</a></li>
<li><a href="buses.transfer_data_to_isochronous_endpoints">How to transfer data to USB isochronous endpoints</a></li>
<li><a href="buses.how_to_use_the_continous_reader_for_getting_data_from_a_usb_endpoint__umdf_">How to use the continuous reader for reading data from a USB pipe</a></li>
</ul>
<h3><a id="writing_to_a_pipe"></a><a id="WRITING_TO_A_PIPE"></a>
      Writing to a Pipe</h3>
<p>To write data to a USB output pipe, your driver can use one (or both) of the following techniques:</p>
<ul>
<li>
<p>Write data synchronously</p>
<p>To write data synchronously to a USB output pipe, your driver can call the <a href="wdf.wdfusbtargetpipewritesynchronously"><b>WdfUsbTargetPipeWriteSynchronously</b></a> method. This method builds and sends a write request, and it returns after the I/O operation has completed. </p>
</li>
<li>
<p>Write data asynchronously</p>
<p>To write data asynchronously to a USB input pipe, your driver can call the <a href="wdf.wdfusbtargetpipeformatrequestforwrite"><b>WdfUsbTargetPipeFormatRequestForWrite</b></a> method to build a write request. Then the driver can call <a href="wdf.wdfrequestsend"><b>WdfRequestSend</b></a> to send the request asynchronously.</p>
</li>
</ul>
<p>For related information, see <a href="buses.usb_bulk_and_interrupt_transfer">How to send USB bulk transfer requests</a>.</p>
<h3><a id="stopping_and_resetting_a_pipe"></a><a id="STOPPING_AND_RESETTING_A_PIPE"></a>
      Stopping and Resetting a Pipe</h3>
<p>Your driver can call the following methods to stop or reset a USB pipe:</p>
<p></p>
<dl>
<dt><a id="_________WdfUsbTargetPipeAbortSynchronously________"></a><a id="_________wdfusbtargetpipeabortsynchronously________"></a><a id="_________WDFUSBTARGETPIPEABORTSYNCHRONOUSLY________"></a><a href="wdf.wdfusbtargetpipeabortsynchronously"><b>
        WdfUsbTargetPipeAbortSynchronously
       </b></a></dt>
<dd>
<p>Synchronously sends a request to stop a USB pipe.</p>
</dd>
<dt><a id="_________WdfUsbTargetPipeFormatRequestForAbort________"></a><a id="_________wdfusbtargetpipeformatrequestforabort________"></a><a id="_________WDFUSBTARGETPIPEFORMATREQUESTFORABORT________"></a><a href="wdf.wdfusbtargetpipeformatrequestforabort"><b>
        WdfUsbTargetPipeFormatRequestForAbort
       </b></a></dt>
<dd>
<p>Formats a request to stop a USB pipe. The driver can call <a href="wdf.wdfrequestsend"><b>WdfRequestSend</b></a> to send the request synchronously or asynchronously.</p>
</dd>
<dt><a id="_________WdfUsbTargetPipeResetSynchronously________"></a><a id="_________wdfusbtargetpiperesetsynchronously________"></a><a id="_________WDFUSBTARGETPIPERESETSYNCHRONOUSLY________"></a><a href="wdf.wdfusbtargetpiperesetsynchronously"><b>
        WdfUsbTargetPipeResetSynchronously
       </b></a></dt>
<dd>
<p>Synchronously sends a request to reset a USB pipe.</p>
</dd>
<dt><a id="_________WdfUsbTargetPipeFormatRequestForReset________"></a><a id="_________wdfusbtargetpipeformatrequestforreset________"></a><a id="_________WDFUSBTARGETPIPEFORMATREQUESTFORRESET________"></a><a href="wdf.wdfusbtargetpipeformatrequestforreset"><b>
        WdfUsbTargetPipeFormatRequestForReset
       </b></a></dt>
<dd>
<p>Formats a request to reset a USB pipe. The driver must call <a href="wdf.wdfrequestsend"><b>WdfRequestSend</b></a> to send the request synchronously or asynchronously.</p>
</dd>
</dl>
<p>If your driver's USB target <a href="completing_i_o_requests.htm">completes</a> an I/O request with an error status value, your driver should do the following:</p>
<ol>
<li>
<p>Stop the pipe, and cancel any additional I/O requests that the driver has sent to the USB target, if the target has not completed the requests.</p>
<p>Call <a href="wdf.wdfiotargetstop"><b>WdfIoTargetStop</b></a> with the <a href="wdf.wdf_io_target_sent_io_action"><b>WdfIoTargetCancelSentIo</b></a> flag set.</p>
</li>
<li>
<p>Synchronously send an abort request to the pipe.</p>
<p>Call <a href="wdf.wdfusbtargetpipeabortsynchronously"><b>WdfUsbTargetPipeAbortSynchronously</b></a>, or call <a href="wdf.wdfusbtargetpipeformatrequestforabort"><b>WdfUsbTargetPipeFormatRequestForAbort</b></a> followed by <a href="wdf.wdfrequestsend"><b>WdfRequestSend</b></a> with the <a href="wdf.wdf_request_send_options"><b>WDF_REQUEST_SEND_OPTION_SYNCHRONOUS</b></a> flag set.</p>
</li>
<li>
<p>Synchronously send a reset request to the pipe.</p>
<p>Call <a href="wdf.wdfusbtargetpiperesetsynchronously"><b>WdfUsbTargetPipeResetSynchronously</b></a>, or call <a href="wdf.wdfusbtargetpipeformatrequestforreset"><b>WdfUsbTargetPipeFormatRequestForReset</b></a> followed by <a href="wdf.wdfrequestsend"><b>WdfRequestSend</b></a> with the <a href="wdf.wdf_request_send_options"><b>WDF_REQUEST_SEND_OPTION_SYNCHRONOUS</b></a> flag set.</p>
</li>
<li>
<p>Restart the pipe.</p>
<p>Call <a href="wdf.wdfiotargetstart"><b>WdfIoTargetStart</b></a>.</p>
</li>
<li>
<p>Resend the I/O request that failed, and all I/O requests that followed the failed request. </p>
</li>
</ol>
<p>After a significant number of multiple failures, the driver should attempt to reset the USB port by doing the following:</p>
<ol>
<li>
<p>Stop all active pipes, and cancel any additional I/O requests that the driver has sent to each pipe's USB target, if the target has not completed them.</p>
<p>For each active pipe, call <a href="wdf.wdfiotargetstop"><b>WdfIoTargetStop</b></a> with the <a href="wdf.wdf_io_target_sent_io_action"><b>WdfIoTargetCancelSentIo</b></a> flag set.</p>
</li>
<li>
<p>Synchronously send a request to reset the USB port.</p>
<p>Call <a href="wdf.wdfusbtargetdeviceresetportsynchronously"><b>WdfUsbTargetDeviceResetPortSynchronously</b></a>.</p>
</li>
<li>
<p>Restart the pipes.</p>
<p>Call <a href="wdf.wdfiotargetstart"><b>WdfIoTargetStart</b></a> for each pipe that the driver stopped.</p>
</li>
<li>
<p>Resend the last I/O request that failed, and all I/O requests that followed the failed request. </p>
</li>
</ol>
<p>For related information, see <a href="buses.how_to_recover_from_usb_pipe_errors">How to recover from USB pipe errors</a>.</p>
<h3><a id="sending_a_urb_to_a_pipe"></a><a id="SENDING_A_URB_TO_A_PIPE"></a>
      Sending an URB to a Pipe</h3>
<p>If your KMDF driver communicates with a USB pipe by sending I/O requests that contain URBs, the driver can call the following methods:</p>
<p></p>
<dl>
<dt><a id="_________WdfUsbTargetPipeSendUrbSynchronously__KMDF_only_"></a><a id="_________wdfusbtargetpipesendurbsynchronously__kmdf_only_"></a><a id="_________WDFUSBTARGETPIPESENDURBSYNCHRONOUSLY__KMDF_ONLY_"></a><a href="wdf.wdfusbtargetpipesendurbsynchronously"><b>
        WdfUsbTargetPipeSendUrbSynchronously (KMDF only)</b></a></dt>
<dd>
<p>Synchronously sends an I/O request that contains a URB.</p>
</dd>
<dt><a id="_________WdfUsbTargetPipeFormatRequestForUrb__KMDF_only_"></a><a id="_________wdfusbtargetpipeformatrequestforurb__kmdf_only_"></a><a id="_________WDFUSBTARGETPIPEFORMATREQUESTFORURB__KMDF_ONLY_"></a><a href="wdf.wdfusbtargetpipeformatrequestforurb"><b>
        WdfUsbTargetPipeFormatRequestForUrb (KMDF only)</b></a></dt>
<dd>
<p>Formats an I/O request that contains a URB. The driver can call <a href="wdf.wdfrequestsend"><b>WdfRequestSend</b></a> to send the request synchronously or asynchronously.</p>
</dd>
<dt><a id="_________WdfUsbTargetPipeWdmGetPipeHandle__KMDF_only_"></a><a id="_________wdfusbtargetpipewdmgetpipehandle__kmdf_only_"></a><a id="_________WDFUSBTARGETPIPEWDMGETPIPEHANDLE__KMDF_ONLY_"></a><a href="wdf.wdfusbtargetpipewdmgetpipehandle"><b>
        WdfUsbTargetPipeWdmGetPipeHandle (KMDF only)</b></a></dt>
<dd>
<p>Returns a device's USBD pipe handle. Some URBs require this handle. </p>
</dd>
</dl>
<p> </p>
<p> </p>
<p><a href="mailto:wsddocfb@microsoft.com?subject=Documentation%20feedback [wdf\wdf]:%20Working with USB Pipes%20 RELEASE:%20(3/15/2016)&amp;body=%0A%0APRIVACY STATEMENT%0A%0AWe use your feedback to improve the documentation. We don't use your email address for any other purpose, and we'll remove your email address from our system after the issue that you're reporting is fixed. While we're working to fix this issue, we might send you an email message to ask for more info. Later, we might also send you an email message to let you know that we've addressed your feedback.%0A%0AFor more info about Microsoft's privacy policy, see http://privacy.microsoft.com/en-us/default.aspx." title="Send comments about this topic to Microsoft">Send comments about this topic to Microsoft</a></p>
</div>
<p style="text-align:left;font-family:Arial,sanserif;font-size:100%;color:black">
&#x00a9;&#x00a0;2016 Microsoft. All rights reserved.</p>

</body>
</html>
