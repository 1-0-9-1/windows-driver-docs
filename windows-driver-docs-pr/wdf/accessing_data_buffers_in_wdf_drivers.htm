<html xmlns:msxsl="urn:schemas-microsoft-com:xslt" xmlns:mssdk="winsdk" xmlns:script="urn:script" xmlns:build="urn:build" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="Description" content="When a Windows Driver Frameworks (WDF) driver receives a read, write, or device I/O control request, the request object contains either an input buffer, an output buffer, or both."/>
<meta name="MSHAttr" content="PreferredSiteName:MSDN"/>
<meta name="MSHAttr" content="PreferredLib:/library/windows/hardware"/>
<title>Accessing Data Buffers in WDF Drivers (KMDF or UMDF)</title>

<meta name="MS-HAID" content="Ch3_DFIoPackage_ef2ec270-0bcb-4ce9-b6b0-4dd8d4ea9def.xml"/>
<meta name="MS-HAID" content="kmdf.accessing_data_buffers_in_framework_based_drivers"/>
<meta name="MS-HAID" content="kmdf.accessing_data_buffers_in_kmdf_drivers"/>
<meta name="MS-HAID" content="wdf.accessing_data_buffers_in_kmdf_drivers"/>
<meta name="MS-HAID" content="wdf.accessing_data_buffers_in_wdf_drivers"/>


<link rel="STYLESHEET" type="text/css" HREF="../common/backsdk4.css"/>


</head>
<body>

<div id="mainSection">
<div class="clsServerSDKContent">
<h1><a id="wdf.accessing_data_buffers_in_wdf_drivers"></a>Accessing Data Buffers in WDF Drivers (KMDF or UMDF)</h1>
</div>
<p>When a Windows Driver Frameworks (WDF) driver receives a read, write, or device I/O control request, the request object contains either an input buffer, an output buffer, or both.</p>
<p>Input buffers contain information that the driver needs. For write requests, this information is typically data that a function driver must send to a device. For device I/O control requests, an input buffer might contain information that indicates the type of operation that the driver must perform.</p>
<p>Output buffers receive information from the driver. For read requests, this information is typically data that a function driver receives from a device. For device I/O control requests, an output buffer might receive status or other information that was specified by the request's I/O control code.</p>
<p>The technique that your driver uses to access a request's data buffers depends on the driver's method for accessing data buffers for a device. There are three access methods: </p>
<ul>
<li><a href="#buffered">Buffered I/O</a>. The I/O manager creates intermediate buffers that it shares with the driver.</li>
<li><a href="#direct">Direct I/O</a>. The I/O manager locks the buffer space into physical memory, and then provides the driver with direct access to the buffer space.</li>
<li><a href="#neither">Neither buffered nor direct I/O</a>. The I/O manager provides the driver with the virtual addresses of the request's buffer space. The I/O manager does not validate the request's buffer space, so the driver must verify that the buffer space is accessible and lock the buffer space into physical memory.</li>
</ul>
<p>A Kernel-Mode Driver Framework (KMDF) driver can use any of the three access methods.  A User-Mode Driver Framework (UMDF) driver can use buffered or direct I/O for read, write, and IOCTL requests, and can <a href="managing_buffer_access_methods_in_umdf_drivers.htm#using_neither_buffered_i_o_nor_direct_i_o_in_umdf_drivers">convert requests that specify the <b>METHOD_NEITHER</b> method</a>.</p>
<h2><a id="ddk_preprocessing_i_o_requests_df"></a><a id="DDK_PREPROCESSING_I_O_REQUESTS_DF"></a>Specifying Buffer Access Method</h2>
<p></p>
<dl>
<dt><a id="KMDF_Drivers"></a><a id="kmdf_drivers"></a><a id="KMDF_DRIVERS"></a><b>KMDF Drivers</b></dt>
<dd>
<p></p>
<p>For read and write requests, all drivers in a driver stack must use the same method for accessing a device's buffers, except for the highest-level driver, which can use the "neither" method, regardless of which method is used by lower drivers.</p>
<p>Starting in version 1.13, a KMDF driver specifies the access method for all of a device's read and write requests by calling <a href="wdf.wdfdeviceinitsetiotypeex"><b>WdfDeviceInitSetIoTypeEx</b></a> for each device. For example, if a driver specifies the buffered I/O method for one of its devices, the I/O manager uses the buffered I/O method when delivering read and write requests to the driver for that device.</p>
<p>For device I/O control requests, the I/O control code (IOCTL) contains bits that specify the buffer access method. As a result, a KMDF driver does not need to take any action to select a buffering method for IOCTLs. For more information about IOCTLs, see <a href="kernel.defining_i_o_control_codes">Defining I/O Control Codes</a>. Unlike read and write requests, all of a device's IOCTLs do not have to specify the same access method.</p>
</dd>
<dt><a id="UMDF_Drivers"></a><a id="umdf_drivers"></a><a id="UMDF_DRIVERS"></a><b>UMDF Drivers</b></dt>
<dd>
<p></p>
<p>A UMDF driver specifies <i>preferences</i> for the access method that the framework uses for read and write requests, as well as device I/O control requests. The values that a UMDF driver provides are only preferences, and are not guaranteed to be used by the framework.  For more information, see <a href="managing_buffer_access_methods_in_umdf_drivers.htm">Managing Buffer Access Methods in UMDF Drivers</a>.</p>
<p>A UMDF driver specifies the access method for all of a device's read, write and IOCTL requests by calling <a href="wdf.wdfdeviceinitsetiotypeex"><b>WdfDeviceInitSetIoTypeEx</b></a> for each device. For example, if a driver specifies the buffered I/O method for one of its devices, the framework uses the buffered I/O method when delivering read, write and IOCTL requests to the driver for that device.</p>
<p>Note the difference in buffer access technique for IOCTLs between KMDF and UMDF. KMDF drivers do not specify buffer access method for IOCTLs, whereas UMDF drivers do specify the buffer access method for IOCTLs.</p>
</dd>
</dl>
<p>If a WDF driver describes an I/O request's buffer by using a technique that is incorrect for the I/O method that an I/O target uses, the framework corrects the buffer description. For example, if a driver uses an MDL to describe a buffer that it passes to <a href="wdf.wdfiotargetsendreadsynchronously"><b>WdfIoTargetSendReadSynchronously</b></a>, and if the I/O target uses buffered I/O (which requires that buffers be specified using virtual addresses instead of MDLs), the framework converts the buffer description from an MDL to a virtual address and length. However, it is more efficient if your driver specifies buffers in the correct format.</p>
<p>For information about framework memory objects, lookaside lists, MDLs, and local buffers, see <a href="using_memory_buffers.htm">Using Memory Buffers</a>.</p>
<p>For information about when memory buffers are deleted, see <a href="memory_buffer_life_cycle.htm">Memory Buffer Life Cycle</a>.</p>
<h2><a id="buffered"></a><a id="BUFFERED"></a>
      Accessing Data Buffers for Buffered I/O</h2>
<p>If your driver is using buffered I/O, its behavior changes depending on the type of data request and whether it's using KMDF or UMDF.</p>
<p></p>
<dl>
<dt><a id="KMDF_Drivers"></a><a id="kmdf_drivers"></a><a id="KMDF_DRIVERS"></a><b>KMDF Drivers</b></dt>
<dd>
<p></p>
<p>When a KMDF driver uses buffered I/O, the I/O manager creates one intermediate buffer that the driver can access for every type of request. Here's what happens:</p>
<ul>
<li>Write requests. The I/O manager transfers input info from the calling app's input buffer before it calls the driver stack. Then, the KMDF driver reads input info from the intermediate buffer and writes it to the device.</li>
<li>Read requests. The KMDF driver reads info from the device and stores it in the intermediate buffer. Then, the I/O manager copies the output data from the intermediate buffer to the app's output buffer.</li>
<li>Device I/O control requests. The KMDF driver reads or writes data for that request to or from the intermediate buffer.</li>
</ul>
</dd>
<dt><a id="UMDF_Drivers"></a><a id="umdf_drivers"></a><a id="UMDF_DRIVERS"></a><b>UMDF Drivers</b></dt>
<dd>
<p></p>
<p>When a UMDF driver uses buffered I/O, the driver host process creates one or two intermediate buffers, depending on the type of request. Here's what happens:</p>
<ul>
<li>Write requests. The framework creates one buffer, transfers input info from the calling app's input buffer, and then calls the driver stack. The UMDF driver reads input info from the intermediate buffer and writes it to the device.</li>
<li>Read requests. A UMDF driver reads info from a device and stores it in a buffer that the framework created. The driver host process copies the output data from the intermediate buffer to the app's output buffer.</li>
<li>Device I/O control requests. The framework creates two buffers corresponding to input and output buffers of the IOCTL that the driver can access. The framework copies the input info from the IOCTL into the new intermediate buffer and makes it available to the driver. The framework does not copy the contents of the output buffer, so the driver shouldn't attempt to read from it (otherwise it will end up reading garbage data). Any data that the driver writes to the output buffer is copied back into the original IOCTL buffer and is returned to the app upon successful completion of the I/O request. Note that any data that the driver writes to the input buffer is discarded and not returned to the calling app.</li>
</ul>
</dd>
</dl>
<p>To retrieve a handle to a framework memory object that represents the buffer, both KMDF and UMDF drivers call <a href="wdf.wdfrequestretrieveinputmemory"><b>WdfRequestRetrieveInputMemory</b></a> or <a href="wdf.wdfrequestretrieveoutputmemory"><b>WdfRequestRetrieveOutputMemory</b></a>, depending on whether this is a read or write request. The driver can then retrieve a pointer to the buffer by calling <a href="wdf.wdfmemorygetbuffer"><b>WdfMemoryGetBuffer</b></a>. To read and write the buffer, the driver calls <a href="wdf.wdfmemorycopyfrombuffer"><b>WdfMemoryCopyFromBuffer</b></a> or <a href="wdf.wdfmemorycopytobuffer"><b>WdfMemoryCopyToBuffer</b></a>.</p>
<p>To retrieve the virtual address and length of the buffer, the driver calls   <a href="wdf.wdfrequestretrieveinputbuffer"><b>WdfRequestRetrieveInputBuffer</b></a> or <a href="wdf.wdfrequestretrieveoutputbuffer"><b>WdfRequestRetrieveOutputBuffer</b></a>.</p>
<p>To allocate and build a memory descriptor list (MDL) for the buffer, a KMDF driver calls <a href="wdf.wdfrequestretrieveinputwdmmdl"><b>WdfRequestRetrieveInputWdmMdl</b></a> or <a href="wdf.wdfrequestretrieveoutputwdmmdl"><b>WdfRequestRetrieveOutputWdmMdl</b></a>.</p>
<h2><a id="direct"></a><a id="DIRECT"></a>
      Accessing Data Buffers for Direct I/O</h2>
<p></p>
<dl>
<dt><a id="KMDF_Drivers"></a><a id="kmdf_drivers"></a><a id="KMDF_DRIVERS"></a><b>KMDF Drivers</b></dt>
<dd>
<p></p>
<p>If your driver is using direct I/O, the I/O manager verifies the accessibility of the buffer space that the originator of the I/O request (typically a user-mode application) specified, locks the buffer space into physical memory, and then provides the driver with direct access to the buffer space.</p>
</dd>
<dt><a id="UMDF_Drivers"></a><a id="umdf_drivers"></a><a id="UMDF_DRIVERS"></a><b>UMDF Drivers</b></dt>
<dd>
<p></p>
<p>If your driver has specified a preference for direct I/O, and all the UMDF requirements for direct I/O have been met (see <a href="managing_buffer_access_methods_in_umdf_drivers.htm">Managing Buffer Access Methods in UMDF Drivers</a>), the framework maps the memory buffer it receives from the I/O manager directly into the driverâ€™s host process address space, and thus provides the driver with direct access to the buffer space.</p>
</dd>
</dl>
<p>To retrieve a handle to a framework memory object that represents the buffer space, the driver calls <a href="wdf.wdfrequestretrieveinputmemory"><b>WdfRequestRetrieveInputMemory</b></a> or <a href="wdf.wdfrequestretrieveoutputmemory"><b>WdfRequestRetrieveOutputMemory</b></a>. The driver can then retrieve a pointer to the buffer by calling <a href="wdf.wdfmemorygetbuffer"><b>WdfMemoryGetBuffer</b></a>. To read and write the buffer, the driver calls <a href="wdf.wdfmemorycopyfrombuffer"><b>WdfMemoryCopyFromBuffer</b></a> or <a href="wdf.wdfmemorycopytobuffer"><b>WdfMemoryCopyToBuffer</b></a>.</p>
<p>To retrieve the virtual address and length of the buffer space, the driver calls <a href="wdf.wdfrequestretrieveinputbuffer"><b>WdfRequestRetrieveInputBuffer</b></a> or <a href="wdf.wdfrequestretrieveoutputbuffer"><b>WdfRequestRetrieveOutputBuffer</b></a>.</p>
<p>If a device's drivers are using direct I/O, the I/O manager describes buffers by using MDLs. To retrieve a pointer to a buffer's MDL, a KMDF driver calls <a href="wdf.wdfrequestretrieveinputwdmmdl"><b>WdfRequestRetrieveInputWdmMdl</b></a> or <a href="wdf.wdfrequestretrieveoutputwdmmdl"><b>WdfRequestRetrieveOutputWdmMdl</b></a>. A UMDF driver cannot access MDLs.</p>
<h2><a id="neither"></a><a id="NEITHER"></a>
      Accessing Data Buffers for Neither Buffered Nor Direct I/O</h2>
<p></p>
<dl>
<dt><a id="KMDF_Drivers"></a><a id="kmdf_drivers"></a><a id="KMDF_DRIVERS"></a><b>KMDF Drivers</b></dt>
<dd>
<p></p>
<p>If your driver is using the buffer access method known as the <i>neither buffered I/O nor direct I/O method</i> (or, the "neither" method, for short), the I/O manager simply provides the driver with the virtual addresses that the originator of the I/O request specified for the request's buffer space. The I/O manager does not validate the I/O request's buffer space, so the driver must verify that the buffer space is accessible and lock the buffer space into physical memory. </p>
<p>The virtual addresses that the I/O manager provides can be accessed only in the process context of the originator of the I/O request. Only the highest-level driver in the driver stack is guaranteed to execute in the originator's process context. </p>
<p>To obtain access to an I/O request's buffer space, the highest-level driver must provide an <a href="wdf.evtioincallercontext"><i>EvtIoInCallerContext</i></a> callback function. The framework calls this callback function each time it receives an I/O request for the driver. </p>
<p>If a request's buffer access method is "neither," a KMDF driver must do the following for each buffer:</p>
<ol>
<li>
<p>Call <a href="wdf.wdfrequestretrieveunsafeuserinputbuffer"><b>WdfRequestRetrieveUnsafeUserInputBuffer</b></a> or <a href="wdf.wdfrequestretrieveunsafeuseroutputbuffer"><b>WdfRequestRetrieveUnsafeUserOutputBuffer</b></a> to obtain the buffer's virtual address.</p>
</li>
<li>
<p>Call <a href="wdf.wdfrequestprobeandlockuserbufferforread"><b>WdfRequestProbeAndLockUserBufferForRead</b></a> or <a href="wdf.wdfrequestprobeandlockuserbufferforwrite"><b>WdfRequestProbeAndLockUserBufferForWrite</b></a> to probe and lock the buffer and to obtain a handle to a framework memory object for the buffer. </p>
</li>
<li>
<p>Save the memory object handles in the request's <a href="using_request_object_context.htm">context space</a>.</p>
</li>
<li>
<p>Call <a href="wdf.wdfdeviceenqueuerequest"><b>WdfDeviceEnqueueRequest</b></a>, which returns the request to the framework.</p>
</li>
</ol>
<p>The framework subsequently adds the request to one of the driver's I/O queues. If the driver has provided <a href="request_handlers.htm">request handlers</a>, the framework will eventually call the appropriate request handler.</p>
<p>The request handler can retrieve the request's memory object handles from the request's context space. The driver can pass the handles to <a href="wdf.wdfmemorygetbuffer"><b>WdfMemoryGetBuffer</b></a> to obtain the buffer's address. </p>
<p>Occasionally, a highest-level driver must use the preceding steps to access a user-mode buffer, even if the driver is not using the "neither" access method. For example, suppose the driver is using buffered I/O. An I/O control code that uses the buffered access method might pass a structure that contains an embedded pointer to a user-mode buffer. In such a case, the driver must provide an <a href="wdf.evtioincallercontext"><i>EvtIoInCallerContext</i></a> callback function that extracts the pointers from the structure and then uses the preceding steps 2 through 4.</p>
</dd>
<dt><a id="UMDF_Drivers"></a><a id="umdf_drivers"></a><a id="UMDF_DRIVERS"></a><b>UMDF Drivers</b></dt>
<dd>
<p></p>
<p>UMDF doesnâ€™t support neither buffered nor direct I/O type buffers, so a UMDF driver never needs to handle this type of buffer directly.</p>
<p>However, if the framework receives such buffers for read or write from the I/O manager, it makes them available to a UMDF driver as buffered I/O or direct I/O, depending on the access method selected by the driver. If the framework receives an IOCTL specifying the "neither" buffer method, it can optionally convert the buffer access method of the IOCTL request to buffered I/O or direct I/O based on the presence of an INF directive. See <a href="managing_buffer_access_methods_in_umdf_drivers.htm">Managing Buffer Access Methods in UMDF Drivers</a> for more info.</p>
</dd>
</dl>
<p> </p>
<p> </p>
<p><a href="mailto:wsddocfb@microsoft.com?subject=Documentation%20feedback [wdf\wdf]:%20Accessing Data Buffers in WDF Drivers (KMDF or UMDF)%20 RELEASE:%20(3/15/2016)&amp;body=%0A%0APRIVACY STATEMENT%0A%0AWe use your feedback to improve the documentation. We don't use your email address for any other purpose, and we'll remove your email address from our system after the issue that you're reporting is fixed. While we're working to fix this issue, we might send you an email message to ask for more info. Later, we might also send you an email message to let you know that we've addressed your feedback.%0A%0AFor more info about Microsoft's privacy policy, see http://privacy.microsoft.com/en-us/default.aspx." title="Send comments about this topic to Microsoft">Send comments about this topic to Microsoft</a></p>
</div>
<p style="text-align:left;font-family:Arial,sanserif;font-size:100%;color:black">
&#x00a9;&#x00a0;2016 Microsoft. All rights reserved.</p>

</body>
</html>
