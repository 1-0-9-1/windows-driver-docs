<html xmlns:msxsl="urn:schemas-microsoft-com:xslt" xmlns:mssdk="winsdk" xmlns:script="urn:script" xmlns:build="urn:build" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="Description" content="Using Device Interfaces in UMDF Drivers"/>
<meta name="MSHAttr" content="PreferredSiteName:MSDN"/>
<meta name="MSHAttr" content="PreferredLib:/library/windows/hardware"/>
<title>Using Device Interfaces in UMDF Drivers</title>

<meta name="MS-HAID" content="umdfobjectdg_476afa48-90c7-4f4a-9396-bdbb2323e684.xml"/>
<meta name="MS-HAID" content="umdf.using_device_interfaces_in_umdf_based_drivers"/>
<meta name="MS-HAID" content="umdf.using_device_interfaces_in_umdf_drivers"/>
<meta name="MS-HAID" content="wdf.using_device_interfaces_in_umdf_drivers"/>


<link rel="STYLESHEET" type="text/css" HREF="../common/backsdk4.css"/>


</head>
<body>

<div id="mainSection">
<div class="clsServerSDKContent">
<h1><a id="wdf.using_device_interfaces_in_umdf_drivers"></a>Using Device Interfaces in UMDF Drivers</h1>
</div>
<p class="CCE_Message">[This topic applies to UMDF 1.<i>x</i>.]</p>
<p>A <i>device interface</i> is a symbolic link to a Plug and Play (PnP) device that an application can use to access the device. A user-mode application can pass the interface's symbolic link name to an API element, such as the Microsoft Win32 <a href="fs.createfile"><b>CreateFile</b></a> function. To obtain a device interface's symbolic link name, the user-mode application can call <b>SetupDi</b> functions. For more information about SetupDi functions, see SetupDi Device Interface Functions.</p>
<p>Each device interface belongs to a <i>device interface class</i>. For example, a driver stack for a CD-ROM device might provide an interface that belongs to the GUID_DEVINTERFACE_CDROM class. One of the CD-ROM device's drivers would register an instance of the GUID_DEVINTERFACE_CDROM class to inform the system and applications that a CD-ROM device is available. For more information about device interface classes, see <a href="devinst.overview_of_device_interface_classes">Introduction to Device Interfaces</a>.</p>
<h3><a id="registering_a_device_interface"></a><a id="REGISTERING_A_DEVICE_INTERFACE"></a>Registering a Device Interface</h3>
<p>To register an instance of a device interface class, a UMDF-based driver can call <a href="wdf.iwdfdevice_createdeviceinterface"><b>IWDFDevice::CreateDeviceInterface</b></a> from within its <a href="wdf.idriverentry_ondeviceadd"><b>IDriverEntry::OnDeviceAdd</b></a> callback function. If the driver supports multiple instances of the interface, it can assign a unique reference string to each instance.</p>
<h3><a id="enabling_and_disabling_a_device_interface"></a><a id="ENABLING_AND_DISABLING_A_DEVICE_INTERFACE"></a>Enabling and Disabling a Device Interface</h3>
<p>If creation succeeds, the framework automatically enables and disables the interface based on the device's PnP state.</p>
<p>In addition, a driver can disable and re-enable a device interface as necessary. For example, if a driver determines that its device has stopped responding, the driver can call <a href="wdf.iwdfdevice_assigndeviceinterfacestate"><b>IWDFDevice::AssignDeviceInterfaceState</b></a> to disable the device's interfaces and prohibit applications from obtaining new handles to the interface. (Existing handles to the interface are not affected.) If the device later becomes available, the driver can call <b>IWDFDevice::AssignDeviceInterfaceState</b> again to re-enable the interfaces. </p>
<h3><a id="receiving_requests_to_access_a_device_interface"></a><a id="RECEIVING_REQUESTS_TO_ACCESS_A_DEVICE_INTERFACE"></a>Receiving Requests to Access a Device Interface</h3>
<p>When an application requests access to a driver's device interface, the framework calls the driver's <a href="wdf.iqueuecallbackcreate_oncreatefile"><b>IQueueCallbackCreate::OnCreateFile</b></a> callback function. The driver can call <a href="wdf.iwdffile_retrievefilename"><b>IWDFFile::RetrieveFileName</b></a> to obtain the name of the device or file that the application is accessing. If the driver specified a reference string when it registered the device interface, the operating system includes the reference string in the file or device name that <b>IWDFFile::RetrieveFileName</b> returns.</p>
<h3><a id="creating_device_events"></a><a id="CREATING_DEVICE_EVENTS"></a>Creating Device Events</h3>
<p>Your UMDF-based driver can create device-specific, custom events (called <i>device events</i>) by calling <a href="wdf.iwdfdevice_postevent"><b>IWDFDevice::PostEvent</b></a>. A driver that has registered to use any of the device's interfaces can receive notifications of a device's custom events. UMDF-based drivers receive such notifications by providing an <a href="wdf.iremoteinterfacecallbackevent_onremoteinterfaceevent"><b>IRemoteInterfaceCallbackEvent::OnRemoteInterfaceEvent</b></a> callback function. </p>
<p>Custom events are unique to the device. Both the developer of the driver that creates the event and the developer of the driver that receives the event must understand the meaning of the event.</p>
<h3><a id="accessing_another_driver_s_device_interface"></a><a id="ACCESSING_ANOTHER_DRIVER_S_DEVICE_INTERFACE"></a>Accessing Another Driver's Device Interface</h3>
<p>If you want your UMDF-based driver to send I/O requests to a device interface that another driver provides, you can create a <a href="general_i_o_targets_in_umdf.htm">remote I/O target</a> that represents the device interface. </p>
<p>First, your driver must register to receive a notification when a device interface is available. Use the following steps:</p>
<ol>
<li>
<p>When your driver calls <a href="wdf.iwdfdriver_createdevice"><b>IWDFDriver::CreateDevice</b></a>, the driver can provide an <a href="wdf.ipnpcallbackremoteinterfacenotification">IPnpCallbackRemoteInterfaceNotification</a> interface. The <a href="wdf.ipnpcallbackremoteinterfacenotification_onremoteinterfacearrival"><b>IPnpCallbackRemoteInterfaceNotification::OnRemoteInterfaceArrival</b></a> callback function of this interface informs your driver when device interfaces are available.</p>
</li>
<li>
<p>After your driver calls <a href="wdf.iwdfdriver_createdevice"><b>IWDFDriver::CreateDevice</b></a>, it can call <a href="wdf.iwdfdevice2_registerremoteinterfacenotification"><b>IWDFDevice2::RegisterRemoteInterfaceNotification</b></a> for each device interface that the driver will use. </p>
</li>
</ol>
<p>Subsequently, the framework calls the driver's <a href="wdf.ipnpcallbackremoteinterfacenotification_onremoteinterfacearrival"><b>IPnpCallbackRemoteInterfaceNotification::OnRemoteInterfaceArrival</b></a> callback function each time that a specified device interface becomes available. The callback function can call <a href="wdf.iwdfremoteinterfaceinitialize_getinterfaceguid"><b>IWDFRemoteInterfaceInitialize::GetInterfaceGuid</b></a> and <a href="wdf.iwdfremoteinterfaceinitialize_retrievesymboliclink"><b>IWDFRemoteInterfaceInitialize::RetrieveSymbolicLink</b></a> to determine which device interface has arrived.</p>
<p>Your driver's <a href="wdf.ipnpcallbackremoteinterfacenotification_onremoteinterfacearrival"><b>IPnpCallbackRemoteInterfaceNotification::OnRemoteInterfaceArrival</b></a> callback function should typically do the following:</p>
<ol>
<li>
<p>Call <a href="wdf.iwdfdevice2_createremoteinterface"><b>IWDFDevice2::CreateRemoteInterface</b></a> to create a remote interface object, optionally providing <a href="wdf.iremoteinterfacecallbackevent">IRemoteInterfaceCallbackEvent</a> and <a href="wdf.iremoteinterfacecallbackremoval">IRemoteInterfaceCallbackRemoval</a> interfaces.</p>
</li>
<li>
<p>Call <a href="wdf.iwdfdevice2_createremotetarget"><b>IWDFDevice2::CreateRemoteTarget</b></a> to create a remote target object, optionally providing an <a href="wdf.iremotetargetcallbackremoval">IRemoteTargetCallbackRemoval</a> interface.</p>
</li>
<li>
<p>Call <a href="wdf.iwdfremotetarget_openremoteinterface"><b>IWDFRemoteTarget::OpenRemoteInterface</b></a> to connect the device interface to the remote target.</p>
<p>If the device interface is one that the SWENUM software device enumerator creates, your driver must call <b>OpenRemoteInterface</b> from a work item. (For example, see the <b>QueueUserWorkItem</b> function in the Windows SDK.)</p>
</li>
</ol>
<p>Now the driver can format and send I/O requests to the remote I/O target.</p>
<p>In addition to the <a href="wdf.ipnpcallbackremoteinterfacenotification_onremoteinterfacearrival"><b>IPnpCallbackRemoteInterfaceNotification::OnRemoteInterfaceArrival</b></a> callback function, a UMDF-based driver can provide two additional callback functions to receive notifications of device interface events:</p>
<ul>
<li>
<p>The <a href="wdf.iremoteinterfacecallbackremoval_onremoteinterfaceremoval"><b>IRemoteInterfaceCallbackRemoval::OnRemoteInterfaceRemoval</b></a> callback function notifies the driver when a device interface is removed.</p>
</li>
<li>
<p>The <a href="wdf.iremoteinterfacecallbackevent_onremoteinterfaceevent"><b>IRemoteInterfaceCallbackEvent::OnRemoteInterfaceEvent</b></a> callback function notifies the driver when a device's custom events arrive.</p>
</li>
</ul>
<p> </p>
<p> </p>
<p><a href="mailto:wsddocfb@microsoft.com?subject=Documentation%20feedback [wdf\wdf]:%20Using Device Interfaces in UMDF Drivers%20 RELEASE:%20(3/15/2016)&amp;body=%0A%0APRIVACY STATEMENT%0A%0AWe use your feedback to improve the documentation. We don't use your email address for any other purpose, and we'll remove your email address from our system after the issue that you're reporting is fixed. While we're working to fix this issue, we might send you an email message to ask for more info. Later, we might also send you an email message to let you know that we've addressed your feedback.%0A%0AFor more info about Microsoft's privacy policy, see http://privacy.microsoft.com/en-us/default.aspx." title="Send comments about this topic to Microsoft">Send comments about this topic to Microsoft</a></p>
</div>
<p style="text-align:left;font-family:Arial,sanserif;font-size:100%;color:black">
&#x00a9;&#x00a0;2016 Microsoft. All rights reserved.</p>

</body>
</html>
