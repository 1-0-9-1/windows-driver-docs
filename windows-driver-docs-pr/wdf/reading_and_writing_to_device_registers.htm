<html xmlns:msxsl="urn:schemas-microsoft-com:xslt" xmlns:mssdk="winsdk" xmlns:script="urn:script" xmlns:build="urn:build" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="Description" content="Reading and Writing to Device Registers"/>
<meta name="MSHAttr" content="PreferredSiteName:MSDN"/>
<meta name="MSHAttr" content="PreferredLib:/library/windows/hardware"/>
<title>Reading and Writing to Device Registers</title>

<meta name="MS-HAID" content="wdf.reading_and_writing_to_device_registers"/>


<link rel="STYLESHEET" type="text/css" HREF="../common/backsdk4.css"/>


</head>
<body>

<div id="mainSection">
<div class="clsServerSDKContent">
<h1><a id="wdf.reading_and_writing_to_device_registers"></a>Reading and Writing to Device Registers</h1>
</div>
<p>
After a driver has mapped registers as described in <a href="finding_and_mapping_hardware_resources.htm">Finding and Mapping Hardware Resources</a>, a KMDF driver uses the <a href="kernel.hal_library_routines"><b>HAL Library Routines</b></a> to read and write to registers, while a UMDF driver (version 2.0 or later) typically uses the <a href="wdf.wdf_register_port_access_functions">WDF Register/Port Access Functions</a>.</p>
<p>If a UMDF  driver needs to access memory-mapped registers directly, it can set the INF directive <b>UmdfRegisterAccessMode</b> to <b>RegisterAccessUsingUserModeMapping</b> and then call <a href="wdf.wdfdevicegethardwareregistermappedaddress"><b>WdfDeviceGetHardwareRegisterMappedAddress</b></a> to retrieve a user-mode mapped address. Because the framework doesn't validate read and write accesses performed in this way, this technique is not recommended for register access.  For a complete list of UMDF INF directives, see <a href="specifying_wdf_directives_in_inf_files.htm">Specifying WDF Directives in INF Files</a>.</p>
<p>The following example includes code that could be compiled using KMDF (1.13 or later) or UMDF (2.0 or later).  The example shows how a driver uses its <a href="wdf.evtdevicepreparehardware"><i>EvtDevicePrepareHardware</i></a> callback function to examine its memory-mapped register resources and map them into user-mode address space. The example then demonstrates how to access the memory locations.</p>
<p>Before accessing device registers and ports, a UMDF driver must set the <b>UmdfDirectHardwareAccess</b> directive to <b>AllowDirectHardwareAccess</b> in the driver's INF file.</p>
<div class="code"><span codelanguage=""><table>
<tr>
<th></th>
</tr>
<tr>
<td>
<pre>
NTSTATUS
 MyDevicePrepareHardware (
    IN WDFDEVICE  Device,
    IN WDFCMRESLIST  ResourcesRaw,
    IN WDFCMRESLIST  ResourcesTranslated
    )
  
{
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc = NULL;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR  descTranslated = NULL;
    PHYSICAL_ADDRESS regBasePA = {0};
    ULONG regLength = 0;
    BOOLEAN found = FALSE;
    ULONG  i;
    PFDO_DATA deviceContext;
    NTSTATUS status = STATUS_SUCCESS;
    
    UNREFERENCED_PARAMETER(ResourcesRaw);

    MyKdPrint(("MyEvtDevicePrepareHardware Device 0x%p ResRaw 0x%p ResTrans "
        "0x%p Count %d\n", Device, ResourcesRaw, ResourcesTranslated,
        WdfCmResourceListGetCount(ResourcesTranslated)));

#ifndef _KERNEL_MODE
    WDF_DEVICE_IO_TYPE stackReadWriteIotype = WdfDeviceIoUndefined; 
    WDF_DEVICE_IO_TYPE stackIoctlIotype = WdfDeviceIoUndefined;
    WdfDeviceGetDeviceStackIoType(Device,
                                  &amp;stackReadWriteIotype,
                                  &amp;stackIoctlIotype);
    MyKdPrint(("Device 0x%p stackReadWriteIoType %S stackIoctlIoType %S\n",
        Device,
        GetIoTypeName(stackReadWriteIotype),
        GetIoTypeName(stackIoctlIotype)
        ));

#endif

    deviceContext = ToasterFdoGetData(Device);
    
    //
    // Scan the list and identify our resource
    //
    for (i = 0; i &lt; WdfCmResourceListGetCount(ResourcesTranslated); i++) {
        desc = WdfCmResourceListGetDescriptor(Resources, i);
        descTranslated =  WdfCmResourceListGetDescriptor(ResourcesTranslated, i);
           
        switch (desc-&gt;Type) {
            case CmResourceTypeMemory:
                MyKdPrint(("EvtPrepareHardware: found CmResourceTypeMemory resources \n"));
                //
                // see if this is the memory resource we're looking for
                // 
                if (desc-&gt;u.Memory.Length == 0x200) {
                    regBasePA = desc-&gt;u.Memory.Start;
                    regLength = desc-&gt;u.Memory.Length;
                    found = TRUE;                    
                }
                break;
                
            case CmResourceTypePort:
                MyKdPrint(("EvtPrepareHardware: found CmResourceTypePort"
                    " resource\n"));

                switch(descTranslated-&gt;Type) {

                case CmResourceTypePort:
                    deviceContext-&gt;PortWasMapped = FALSE;
                    deviceContext-&gt;PortBase = 
                        ULongToPtr(descTranslated-&gt;u.Port.Start.LowPart);
                    deviceContext-&gt;PortCount = descTranslated -&gt;u.Port.Length;
                    MyKdPrint(("Resource Translated Port: (%x) Length: (%d)\n",
                             descTranslated-&gt;u.Port.Start.LowPart,
                             descTranslated-&gt;u.Port.Length));                        
                    break;
                    
                case CmResourceTypeMemory:
                    //
                    // Map the memory
                    //

#if IS_UMDF_DRIVER                    
                    status = WdfDeviceMapIoSpace(
                                            Device,
                                            descTranslated-&gt;u.Memory.Start,
                                            descTranslated-&gt;u.Memory.Length,
                                            MmNonCached,
                                            &amp;deviceContext-&gt;PortBase
                                            );

                    if (!NT_SUCCESS(status)) {
                        WdfVerifierDbgBreakPoint();
                    }
#else
                    deviceContext-&gt;PortBase = (PVOID) 
                                        MmMapIoSpace(
                                            descTranslated-&gt;u.Memory.Start,
                                            descTranslated-&gt;u.Memory.Length,
                                            MmNonCached
                                            );
                    UNREFERENCED_PARAMETER(status);

#endif
                    deviceContext-&gt;PortCount = descTranslated-&gt;u.Memory.Length;
                    deviceContext-&gt;PortWasMapped = TRUE;
                    MyKdPrint(("Resource Translated Memory: (%x) Length: (%d)\n",
                             descTranslated-&gt;u.Memory.Start.LowPart,
                             descTranslated-&gt;u.Memory.Length));                        
                    break;
                default:
                    MyKdPrint(("Unhandled resource_type (0x%x)\n", 
                        descTranslated-&gt;Type));
                }
                break;

            case CmResourceTypeInterrupt:
                MyKdPrint(("EvtPrepareHardware: found CmResourceTypeInterrupt"
                    "resource\n"));
                break;                

            case CmResourceTypeConnection:
                MyKdPrint(("EvtPrepareHardware: found CmResourceTypeConnection"
                    "resource\n"));
                break;                

            default:
                MyKdPrint(("EvtPrepareHardware: found resources of type %d"
                    "(CM_RESOURCE_TYPE)\n", desc-&gt;Type));
                break;
        }
    }


//
// Next, the driver uses register/port access macros to access the port.
//

    if ((PUCHAR)&amp;deviceContext-&gt;PortBase != NULL) {
        UCHAR data;
        
#ifndef _KERNEL_MODE
        data = WDF_READ_PORT_UCHAR(Device, (PUCHAR)deviceContext-&gt;PortBase);
#else
        data = READ_PORT_UCHAR((PUCHAR)deviceContext-&gt;PortBase);
#endif

        MyKdPrint(("Read value %d from port address 0x%p\n", data, 
            deviceContext-&gt;PortBase));
    }
  
  if (i == 0) {
        MyKdPrint(("EvtPrepareHardware: no cm resources found \n"));
    }
    
    return STATUS_SUCCESS;
}



NTSTATUS
 MyDeviceReleaseHardware (
    IN WDFDEVICE  Device,
    IN WDFCMRESLIST  ResourcesTranslated
    )

{
    PFDO_DATA deviceContext;

    UNREFERENCED_PARAMETER(ResourcesTranslated);

    MyKdPrint(("CovEvtDeviceReleaseHardware Device 0x%p ResTrans 0x%p\n", 
        Device, ResourcesTranslated));

    deviceContext = ToasterFdoGetData(Device);

    if (deviceContext-&gt;PortWasMapped) {
#if IS_UMDF_DRIVER
        WdfDeviceUnmapIoSpace(Device,
                              deviceContext-&gt;PortBase,
                              deviceContext-&gt;PortCount);
#else
        MmUnmapIoSpace(deviceContext-&gt;PortBase,
                     deviceContext-&gt;PortCount);
#endif
    }

    return STATUS_SUCCESS;
}
</pre>
</td>
</tr>
</table></span></div>
<p> </p>
<p> </p>
<p><a href="mailto:wsddocfb@microsoft.com?subject=Documentation%20feedback [wdf\wdf]:%20Reading and Writing to Device Registers%20 RELEASE:%20(3/15/2016)&amp;body=%0A%0APRIVACY STATEMENT%0A%0AWe use your feedback to improve the documentation. We don't use your email address for any other purpose, and we'll remove your email address from our system after the issue that you're reporting is fixed. While we're working to fix this issue, we might send you an email message to ask for more info. Later, we might also send you an email message to let you know that we've addressed your feedback.%0A%0AFor more info about Microsoft's privacy policy, see http://privacy.microsoft.com/en-us/default.aspx." title="Send comments about this topic to Microsoft">Send comments about this topic to Microsoft</a></p>
</div>
<p style="text-align:left;font-family:Arial,sanserif;font-size:100%;color:black">
&#x00a9;&#x00a0;2016 Microsoft. All rights reserved.</p>

</body>
</html>
