<html xmlns:msxsl="urn:schemas-microsoft-com:xslt" xmlns:mssdk="winsdk" xmlns:script="urn:script" xmlns:build="urn:build" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="Description" content="Synchronizing Interrupt Code"/>
<meta name="MSHAttr" content="PreferredSiteName:MSDN"/>
<meta name="MSHAttr" content="PreferredLib:/library/windows/hardware"/>
<title>Synchronizing Interrupt Code</title>

<meta name="MS-HAID" content="umdf.synchronizing_interrupt_code"/>
<meta name="MS-HAID" content="wdf.synchronizing_interrupt_code_umdf"/>


<link rel="STYLESHEET" type="text/css" HREF="../common/backsdk4.css"/>


</head>
<body>

<div id="mainSection">
<div class="clsServerSDKContent">
<h1><a id="wdf.synchronizing_interrupt_code_umdf"></a>Synchronizing Interrupt Code</h1>
</div>
<p class="CCE_Message">[This topic applies to UMDF 1.<i>x</i>.]</p>
<p>All driver code that accesses the interrupt data buffer must be synchronized so that only one routine accesses the data at a time.</p>
<p>You can synchronize interrupt code by using either manual interrupt locking or automatic callback serialization.</p>
<h2><a id="Manual_Interrupt_Locking"></a><a id="manual_interrupt_locking"></a><a id="MANUAL_INTERRUPT_LOCKING"></a>Manual Interrupt Locking</h2>
<p>UMDF acquires the interrupt lock before calling the <a href="wdf.oninterruptisr"><i>OnInterruptIsr</i></a>, <a href="wdf.oninterruptdisable"><i>OnInterruptDisable</i></a>, or <a href="wdf.oninterruptenable"><i>OnInterruptEnable</i></a> callbacks.</p>
<p>
If a driver needs to synchronize any code using the interrupt lock, it calls <a href="wdf.iwdfinterrupt_acquireinterruptlock"><b>IWDFInterrupt::AcquireInterruptLock</b></a> and <a href="wdf.iwdfinterrupt_releaseinterruptlock"><b>IWDFInterrupt::ReleaseInterruptLock</b></a>. For example, a driver acquires and releases  the interrupt lock in its <a href="wdf.oninterruptworkitem"><i>OnInterruptWorkItem</i></a> callback routine by using these methods. However, in I/O dispatch callbacks (such as <a href="wdf.iqueuecallbackread_onread"><b>OnRead</b></a> and <a href="wdf.iqueuecallbackwrite_onwrite"><b>OnWrite</b></a>), the driver first calls <a href="wdf.iwdfinterrupt_trytoacquireinterruptlock"><b>IWDFInterrupt::TryToAcquireInterruptLock</b></a>  to decide whether to queue a work item or do the work in same thread to avoid potential deadlock. For an example of a deadlock scenario that can be caused by calling <b>IWDFInterrupt::AcquireInterruptLock</b> from an arbitrary thread context, see the Remarks section of <a href="wdf.iwdfinterrupt_acquireinterruptlock"><b>IWDFInterrupt::AcquireInterruptLock</b></a>.</p>
<p>If <a href="wdf.iwdfinterrupt_trytoacquireinterruptlock"><b>IWDFInterrupt::TryToAcquireInterruptLock</b></a> returns <b>TRUE</b>, the driver has acquired the interrupt lock in the same thread. In this case, the driver performs the work that required that lock, and then calls <a href="wdf.iwdfinterrupt_releaseinterruptlock"><b>ReleaseInterruptLock</b></a>. If <b>IWDFInterrupt::TryToAcquireInterruptLock</b> returns <b>FALSE</b>, the driver  queues a work item and performs the work in its <a href="wdf.onworkitem"><i>OnWorkItem</i></a> callback. In this case, the work item must not use automatic serialization.</p>
<h2><a id="Using_Automatic_Serialization"></a><a id="using_automatic_serialization"></a><a id="USING_AUTOMATIC_SERIALIZATION"></a>Using Automatic Serialization</h2>
<p>A UMDF driver can request automatic callback synchronization by calling <a href="wdf.iwdfdeviceinitialize_setlockingconstraint"><b>IWDFDeviceInitialize::SetLockingConstraint</b></a> with the <i>LockType</i> parameter set to  <b>WdfDeviceLevel</b>. </p>
<p>The driver then sets the <b>AutomaticSerialization</b> member of its <a href="wdf.wudf_interrupt_config"><b>WUDF_INTERRUPT_CONFIG</b></a> structure to <b>TRUE</b> before calling <a href="wdf.iwdfdevice3_createinterrupt"><b>CreateInterrupt</b></a>. </p>
<p>As a result, UMDF serializes the driver's <a href="wdf.oninterruptworkitem"><i>OnInterruptWorkItem</i></a> callbacks with I/O queue, request cancellation, and file object callback routines. In this scenario, UMDF uses the callback lock instead of a per-interrupt object lock.</p>
<p> </p>
<p> </p>
<p><a href="mailto:wsddocfb@microsoft.com?subject=Documentation%20feedback [wdf\wdf]:%20Synchronizing Interrupt Code%20 RELEASE:%20(3/15/2016)&amp;body=%0A%0APRIVACY STATEMENT%0A%0AWe use your feedback to improve the documentation. We don't use your email address for any other purpose, and we'll remove your email address from our system after the issue that you're reporting is fixed. While we're working to fix this issue, we might send you an email message to ask for more info. Later, we might also send you an email message to let you know that we've addressed your feedback.%0A%0AFor more info about Microsoft's privacy policy, see http://privacy.microsoft.com/en-us/default.aspx." title="Send comments about this topic to Microsoft">Send comments about this topic to Microsoft</a></p>
</div>
<p style="text-align:left;font-family:Arial,sanserif;font-size:100%;color:black">
&#x00a9;&#x00a0;2016 Microsoft. All rights reserved.</p>

</body>
</html>
