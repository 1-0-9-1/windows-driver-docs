<html xmlns:msxsl="urn:schemas-microsoft-com:xslt" xmlns:mssdk="winsdk" xmlns:script="urn:script" xmlns:build="urn:build" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="Description" content="Using Control Device Objects"/>
<meta name="MSHAttr" content="PreferredSiteName:MSDN"/>
<meta name="MSHAttr" content="PreferredLib:/library/windows/hardware"/>
<title>Using Control Device Objects</title>

<meta name="MS-HAID" content="Ch8_DFTechniques_3875f46e-9df8-4c34-bf22-522fa53c7090.xml"/>
<meta name="MS-HAID" content="kmdf.using_control_device_objects"/>
<meta name="MS-HAID" content="wdf.using_control_device_objects"/>


<link rel="STYLESHEET" type="text/css" HREF="../common/backsdk4.css"/>


</head>
<body>

<div id="mainSection">
<div class="clsServerSDKContent">
<h1><a id="wdf.using_control_device_objects"></a>Using Control Device Objects</h1>
</div>
<p>A <i>control device object</i> is a framework device object that does not support Plug and Play (PnP) or power management operations. Drivers can use control device objects to represent software-only virtual devices or <i>legacy hardware devices</i> (that is, devices that do not provide PnP or power management capabilities).</p>
<p>A driver that creates a control device object also typically creates a symbolic link for the device object. Applications can send I/O requests to the control device object by passing the symbolic link name to an API element, such as the Microsoft Win32 <a href="fs.createfile"><b>CreateFile</b></a> function.</p>
<p>The framework does not attach control device objects to a <a href="wdm_concepts_for_kmdf_drivers.htm#device_stacks">device stack</a>. Therefore, when an application sends an I/O request to a control device object, the I/O manager delivers the request directly to the driver that created the control device object, instead of to the driver at the top of the stack. (However, an additional driver can call <a href="kernel.ioattachdevice"><b>IoAttachDevice</b></a> to attach a device object above the control device object. In this case, the additional driver receives the I/O request first.) </p>
<h3><a id="uses_of_control_device_objects"></a><a id="USES_OF_CONTROL_DEVICE_OBJECTS"></a>Uses of Control Device Objects</h3>
<p>Two typical uses for control devices are:</p>
<ol>
<li>
<p>A filter driver for a PnP device, if the driver supports a set of custom I/O control codes for applications to use.</p>
<p>If an application attempted to send the custom I/O control codes to the top of the driver stack (by using, for example, the symbolic link name of a <a href="using_device_interfaces.htm">device interface</a>), a driver above the filter driver might fail the I/O request if the driver did not recognize the custom I/O control codes. To avoid this problem, the filter driver can create a control device object. Applications can use the control device object's symbolic link name to send I/O control codes directly to the filter driver. </p>
<p>(Note that a better way for the filter driver to avoid the problem is to act as a bus driver and raw mode. In other words, for each device that the filter driver supports, the driver can create a physical device object (PDO) that does not require a function driver. The driver calls <a href="wdf.wdfpdoinitassignrawdevice"><b>WdfPdoInitAssignRawDevice</b></a> and <a href="wdf.wdfdeviceinitassignname"><b>WdfDeviceInitAssignName</b></a> for each of these devices, and the application can identify a device by name when it sends a custom I/O control code.)</p>
</li>
<li>
<p>A driver for a device that does not support PnP. </p>
<p>Such a driver must use control device objects, because the device objects for such devices do not reside in a device stack and do not provide PnP capabilities. For more information about supporting non-PnP devices, see <a href="using_kernel_mode_driver_framework_with_non_pnp_drivers.htm">Using Kernel-Mode Driver Framework with Non-PnP Drivers</a>. </p>
</li>
</ol>
<h3><a id="creating_a_control_device_object"></a><a id="CREATING_A_CONTROL_DEVICE_OBJECT"></a>Creating a Control Device Object</h3>
<p>To create a control device object, a driver must:</p>
<ol>
<li>
<p>Call <a href="wdf.wdfcontroldeviceinitallocate"><b>WdfControlDeviceInitAllocate</b></a> to obtain a <a href="wdf.wdfdevice_init"><b>WDFDEVICE_INIT</b></a> structure.</p>
</li>
<li>Call object initialization methods, as needed, to initialize the WDFDEVICE_INIT structure. The driver can call only the following initialization methods:<ul>
<li><a href="wdf.wdfcontroldeviceinitsetshutdownnotification"><b>WdfControlDeviceInitSetShutdownNotification</b></a></li>
<li><a href="wdf.wdfdeviceinitassignname"><b>WdfDeviceInitAssignName</b></a></li>
<li><a href="wdf.wdfdeviceinitassignsddlstring"><b>WdfDeviceInitAssignSDDLString</b></a></li>
<li><a href="wdf.wdfdeviceinitassignwdmirppreprocesscallback"><b>WdfDeviceInitAssignWdmIrpPreprocessCallback</b></a></li>
<li><a href="wdf.wdfdeviceinitsetcharacteristics"><b>WdfDeviceInitSetCharacteristics</b></a></li>
<li><a href="wdf.wdfdeviceinitsetdeviceclass"><b>WdfDeviceInitSetDeviceClass</b></a></li>
<li><a href="wdf.wdfdeviceinitsetexclusive"><b>WdfDeviceInitSetExclusive</b></a></li>
<li><a href="wdf.wdfdeviceinitsetfileobjectconfig"><b>WdfDeviceInitSetFileObjectConfig</b></a></li>
<li><a href="wdf.wdfdeviceinitsetioincallercontextcallback"><b>WdfDeviceInitSetIoInCallerContextCallback</b></a></li>
<li><a href="wdf.wdfdeviceinitsetiotype"><b>WdfDeviceInitSetIoType</b></a></li>
<li><a href="wdf.wdfdeviceinitsetrequestattributes"><b>WdfDeviceInitSetRequestAttributes</b></a></li>
</ul>
</li>
<li>
<p>Call <a href="wdf.wdfdevicecreate"><b>WdfDeviceCreate</b></a>, which uses the contents of the WDFDEVICE_INIT structure to create a framework device object.</p>
</li>
<li>Complete the following initialization operations:<ul>
<li><a href="creating_i_o_queues.htm">Create a default I/O queue</a> for the device, if one is needed.</li>
<li>Call <a href="wdf.wdfdeviceconfigurerequestdispatching"><b>WdfDeviceConfigureRequestDispatching</b></a>, if needed.</li>
<li>Call <a href="wdf.wdfdevicecreatesymboliclink"><b>WdfDeviceCreateSymbolicLink</b></a> to create a symbolic link name that applications can use to access the control device.</li>
</ul>
</li>
<li>
<p>Call <a href="wdf.wdfcontrolfinishinitializing"><b>WdfControlFinishInitializing</b></a>.</p>
</li>
</ol>
<h3><a id="rules_for_using_control_device_objects"></a><a id="RULES_FOR_USING_CONTROL_DEVICE_OBJECTS"></a>Rules for Using Control Device Objects</h3>
<p>Drivers that create control device objects must obey the following rules:</p>
<ul>
<li>
<p>Drivers cannot pass the control device object's handle to framework methods that <a href="enumerating_the_devices_on_a_bus.htm">enumerate child devices</a>.</p>
</li>
<li>
<p>Drivers cannot pass the control device object's handle to framework methods that support <a href="using_device_interfaces.htm">device interfaces</a>.</p>
</li>
<li>
<p>Drivers can create I/O queues and register request handlers for the queues, but the framework does not allow the queues to be <a href="using_power_managed_i_o_queues.htm">power-managed</a>.</p>
</li>
<li>
<p>Drivers can create <a href="framework_file_objects.htm">file objects</a> for control device objects.</p>
</li>
</ul>
<h3><a id="naming_a_control_device_object"></a><a id="NAMING_A_CONTROL_DEVICE_OBJECT"></a>Naming a Control Device Object</h3>
<p>All control device objects must be named. Typically, your driver will call <a href="wdf.wdfdeviceinitassignname"><b>WdfDeviceInitAssignName</b></a> to assign a device name and then call <a href="wdf.wdfdevicecreatesymboliclink"><b>WdfDeviceCreateSymbolicLink</b></a> to create a symbolic link name that applications can use to access the object. </p>
<p>If your driver does not call <a href="wdf.wdfdeviceinitassignname"><b>WdfDeviceInitAssignName</b></a> to assign a device name, the framework automatically generates a name for control devices--but your driver cannot call <a href="wdf.wdfdevicecreatesymboliclink"><b>WdfDeviceCreateSymbolicLink</b></a>.</p>
<p>Your driver can call <a href="wdf.wdfdeviceinitsetdeviceclass"><b>WdfDeviceInitSetDeviceClass</b></a> to specify a <a href="devinst.device_setup_classes">device setup class</a> for a control device. The device setup class identifies a section of the registry that contains administrator-supplied information about devices that belong to the setup class. For more information about calling <a href="wdf.wdfdeviceinitsetdeviceclass"><b>WdfDeviceInitSetDeviceClass</b></a>, see <a href="controlling_device_access_in_kmdf_drivers.htm">Controlling Device Access in Framework-Based Drivers</a>.</p>
<h3><a id="receiving_notification_of_system_shutdown"></a><a id="RECEIVING_NOTIFICATION_OF_SYSTEM_SHUTDOWN"></a>Receiving Notification of System Shutdown</h3>
<p>Because control device objects do not support PnP, your driver cannot register callback functions that inform the driver when a device's power state changes. However, the driver can call <a href="wdf.wdfcontroldeviceinitsetshutdownnotification"><b>WdfControlDeviceInitSetShutdownNotification</b></a> to register an <a href="wdf.evtdeviceshutdownnotification"><i>EvtDeviceShutdownNotification</i></a> callback function. This callback function informs the driver when the system is about to lose its power.</p>
<h3><a id="deleting_a_control_device_object"></a><a id="DELETING_A_CONTROL_DEVICE_OBJECT"></a>Deleting a Control Device Object</h3>
<p>Some drivers have to delete their control device objects before the driver unloads, as follows:</p>
<ul>
<li>
<p>If your driver creates control device objects (which do not support PnP or power management), and if the driver also creates framework device objects that support PnP and power management, the driver must eventually call <a href="wdf.wdfobjectdelete"><b>WdfObjectDelete</b></a> at IRQL = PASSIVE_LEVEL to delete the control device objects.</p>
<p>If the driver creates both types of device objects, the operating system cannot unload your driver until the driver has deleted the control device objects. </p>
<p>However, the driver must not delete the control device objects until after the framework has deleted the other device objects. To determine when the framework has deleted the other device objects, your driver should provide <a href="wdf.evtcleanupcallback"><i>EvtCleanupCallback</i></a> functions for those objects. </p>
</li>
<li>
<p>If your driver creates control device objects but does not create framework device objects that support PnP and power management, the driver does not have to delete the control device objects. </p>
<p>In this case, the framework deletes the control device objects after the driver's <a href="wdf.evtdriverunload"><i>EvtDriverUnload</i></a> callback function returns. </p>
</li>
</ul>
<p> </p>
<p> </p>
<p><a href="mailto:wsddocfb@microsoft.com?subject=Documentation%20feedback [wdf\wdf]:%20Using Control Device Objects%20 RELEASE:%20(3/15/2016)&amp;body=%0A%0APRIVACY STATEMENT%0A%0AWe use your feedback to improve the documentation. We don't use your email address for any other purpose, and we'll remove your email address from our system after the issue that you're reporting is fixed. While we're working to fix this issue, we might send you an email message to ask for more info. Later, we might also send you an email message to let you know that we've addressed your feedback.%0A%0AFor more info about Microsoft's privacy policy, see http://privacy.microsoft.com/en-us/default.aspx." title="Send comments about this topic to Microsoft">Send comments about this topic to Microsoft</a></p>
</div>
<p style="text-align:left;font-family:Arial,sanserif;font-size:100%;color:black">
&#x00a9;&#x00a0;2016 Microsoft. All rights reserved.</p>

</body>
</html>
