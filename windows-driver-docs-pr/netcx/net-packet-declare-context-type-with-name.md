---
title: NET_PACKET_DECLARE_CONTEXT_TYPE_WITH_NAME macro
topic_type:
- apiref
api_name:
- NET_PACKET_DECLARE_CONTEXT_TYPE_WITH_NAME
api_location:
- netadapterpacket.h
api_type:
- HeaderDef
---

# NET_PACKET_DECLARE_CONTEXT_TYPE_WITH_NAME macro


[!include[NetAdapterCx Beta Prerelease](../netcx-beta-prerelease.md)]

The NET_PACKET_DECLARE_CONTEXT_TYPE_WITH_NAME macro creates an accessor method with a specified name for a client driver's object-specific context space. Starting in NetAdapterCx 1.1, a second accessor method is also created with the same name as the first, but with the string "FromToken" appended.

Syntax
------

```cpp
void NET_PACKET_DECLARE_CONTEXT_TYPE_WITH_NAME(
    _contexttype,
    _castingfunction
);
```

Parameters
----------

*_contexttype*   
The structure type name of a driver-defined structure that describes the contents of an object's context space.

*_castingfunction*   
A C-language routine name. The macro uses this name as the name for the accessor method that it creates for the object's context space.  You can put any name you like here; the macro will create a new function with this name.

Return value
------------

This macro does not return a value.

Remarks
-------

You can use NET_PACKET_DECLARE_CONTEXT_TYPE_WITH_NAME to define one context per packet.  The per-packet context area is optional.

You may find it helpful to store hardware-specific or bus-specific data in each packet.

NetAdapter automatically zeros the context area when the packet is created.
The context area is not zeroed out if a packet is reused.
If you need to initialize the context areas before the data path starts, initialize them in your [*EvtNetAdapterCreateTxQueue*](evt-net-adapter-create-txqueue.md) handler after calling [**NetTxQueueCreate**](nettxqueuecreate.md); or in the [*EvtNetAdapterCreateRxQueue*](evt-net-adapter-create-rxqueue.md) handler after calling [**NetRxQueueCreate**](netrxqueuecreate.md).

Example
-------

To declare a context area, use the NET_PACKET_DECLARE_CONTEXT_TYPE_WITH_NAME macro after declaring a structure in a header file:

```cpp
typedef struct _MY_TX_PACKET_CONTEXT {
    ULONG MyFlags;
    VOID *MyDescriptor;
} MY_TX_PACKET_CONTEXT;

NET_PACKET_DECLARE_CONTEXT_TYPE_WITH_NAME(MY_TX_PACKET_CONTEXT, GetMyTxPacketContext);
```

Then, when the client creates a queue, associate the packet context with the queue:

```cpp
NET_TXQUEUE_CONFIG txQueueConfig;
NET_TXQUEUE_CONFIG_INIT(&txQueueConfig, . . .);

NET_PACKET_CONTEXT_ATTRIBUTES myTxContextAttributes;
NET_PACKET_CONTEXT_ATTRIBUTES_INIT_TYPE(&myTxContextAttributes, MY_TX_PACKET_CONTEXT);

status = NetTxQueueInitAddPacketContextAttributes(txQueueInit, &myTxContextAttributes);

status = NetTxQueueCreate(. . ., &txQueueConfig, . . .);

// Optional: Initialize the context area of each packet to a non-zero value.
NET_RING_BUFFER *ringBuffer = NetTxQueueGetRingBuffer(txQueue);
for (UINT i = 0; i < ringBuffer->NumberOfElements; i++) {
    NET_PACKET *packet = NetRingBufferGetPacketAtIndex(ringBuffer, i);
    MY_TX_PACKET_CONTEXT *context = GetMyTxPacketContext(packet);
    context->MyFlags = 0x1234;
}
```

In NetAdapterCx 1.1, the ability to add more than one packet context was introduced.

For queues with one packet context, use the first accessor method created by NET_PACKET_DECLARE_CONTEXT_TYPE_WITH_NAME to get to your context.

```cpp
NET_PACKET *packet = NetRingBufferGetNextPacket(ringBuffer);
MY_TX_PACKET_CONTEXT *context = GetMyTxPacketContext(packet);
```

For queues with more than one packet context per packet, use the second accessor method generated by NET_PACKET_DECLARE_CONTEXT_TYPE_WITH_NAME to access a packet context based on its token. Retrieve the token for the packet context by calling [NET_TXQUEUE_GET_PACKET_CONTEXT_TOKEN](net-txqueue-get-packet-context-token.md) with the context typename, then call the second accessor method to get to the context.

```cpp
NET_PACKET *packet = NetRingBufferGetNextPacket(ringBuffer);

MY_TX_PACKET_CONTEXT *firstContext = GetMyTxPacketContextFromToken(NET_TXQUEUE_GET_PACKET_CONTEXT_TOKEN(txQueue, MY_FIRST_TX_PACKET_CONTEXT));
// do something with the first context

MY_TX_PACKET_CONTEXT *secondContext = GetMyTxPacketContextFromToken(NET_TXQUEUE_GET_PACKET_CONTEXT_TOKEN(txQueue, MY_SECOND_TX_PACKET_CONTEXT));
// do something with the second context
```

Requirements
------------

<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><p>Target platform</p></td>
<td align="left">Universal</td>
</tr>
<tr class="even">
<td align="left"><p>Minimum KMDF version</p></td>
<td align="left"><p>1.23</p></td>
</tr>
<tr class="odd">
<td align="left"><p>Minimum NetAdapterCx version</p></td>
<td align="left"><p>1.1</p></td>
</tr>
<tr class="even">
<td align="left"><p>Header</p></td>
<td align="left">Netadapterpacket.h (include Netadaptercx.h)</td>
</tr>
</tbody>
</table>

## See also


[**NetPacketGetTypedContext**](netpacketgettypedcontext.md)

[**WDF_DECLARE_CONTEXT_TYPE_WITH_NAME**](https://msdn.microsoft.com/library/windows/hardware/ff551252)

 

 






